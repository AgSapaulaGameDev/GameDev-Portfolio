<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GameDev Portfolio - Game Developer & Designer</title>
  <meta name="description"
    content="Passionate game developer specializing in 3D design, animation, and interactive gameplay. Expert in Unity, Unreal Engine, and Blender.">

  <style>
    /* CSS Reset and Base Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --background: hsl(220, 25%, 8%);
      --foreground: hsl(210, 40%, 98%);
      --card: hsl(220, 25%, 10%);
      --card-foreground: hsl(210, 40%, 98%);
      --primary: hsl(188, 95%, 50%);
      --primary-foreground: hsl(220, 25%, 8%);
      --secondary: hsl(220, 20%, 15%);
      --secondary-foreground: hsl(210, 40%, 98%);
      --muted: hsl(220, 20%, 20%);
      --muted-foreground: hsl(215, 20%, 65%);
      --border: hsl(220, 20%, 20%);
      --radius: 0.5rem;
    }

    html,
    body {
      height: 100%;
    }

    body {
      background-color: var(--background);
      color: var(--foreground);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      overflow-x: hidden;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 1rem;
    }

    /* Navigation */
    .nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 50;
      background: rgba(34, 40, 56, 0.8);
      backdrop-filter: blur(16px);
      border-bottom: 1px solid var(--border);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      transform: translateY(0);
      padding: 0;
    }

    @media (max-width: 768px) {
      .nav.scrolled {
        padding: 0.5rem 1rem;
      }

      .nav.scrolled .nav-content {
        padding: 0.5rem 1rem;
        max-width: 95%;
      }

      .nav.scrolled .nav-logo {
        font-size: 1.1rem;
      }
    }

    .nav.scrolled {
      background: transparent;
      backdrop-filter: none;
      border-bottom: none;
      box-shadow: none;
      padding: 1rem 2rem;
    }



    .nav-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1.5rem;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border-radius: 0;
      background: transparent;
      border: none;
    }

    .nav.scrolled .nav-content {
      padding: 1rem 2rem;
      background: rgba(34, 40, 56, 0.95);
      backdrop-filter: blur(20px);
      border-radius: 50px;
      border: 1px solid rgba(255, 193, 7, 0.2);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2), 0 0 20px rgba(255, 193, 7, 0.1);
      max-width: 900px;
      margin: 0 auto;
    }

    .nav-logo {
      font-size: 1.75rem;
      font-weight: bold;
      color: var(--primary);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
    }

    .nav.scrolled .nav-logo {
      font-size: 1.4rem;
      color: var(--primary);
    }

    .nav-links {
      display: flex;
      gap: 2rem;
      align-items: center;
      transition: gap 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .nav.scrolled .nav-links {
      gap: 1.5rem;
    }

    .nav-link {
      background: none;
      border: none;
      color: var(--foreground);
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-size: 1.1rem;
      font-weight: 400;
    }

    .nav.scrolled .nav-link {
      font-size: 1rem;
      color: var(--foreground);
      font-weight: 500;
    }

    .nav.scrolled .nav-link:hover {
      color: var(--primary);
    }

    .nav-link:hover {
      color: var(--primary);
    }

    .nav-button {
      background: var(--primary);
      color: var(--primary-foreground);
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: var(--radius);
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-size: 1rem;
    }

    .nav.scrolled .nav-button {
      padding: 0.6rem 1.4rem;
      font-size: 1rem;
      border-radius: 25px;
      background: var(--primary);
      color: var(--primary-foreground);
      font-weight: 600;
    }

    .nav-button:hover {
      background: hsl(188, 95%, 45%);
      box-shadow: 0 0 30px hsla(188, 95%, 50%, 0.5);
    }

    .mobile-menu-button {
      display: none;
      background: none;
      border: none;
      color: var(--foreground);
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .nav.scrolled .mobile-menu-button {
      transform: scale(0.9);
    }

    .mobile-nav {
      display: none;
      flex-direction: column;
      gap: 1rem;
      padding: 1rem;
      border-top: 1px solid var(--border);
      background: rgba(34, 40, 56, 0.95);
      backdrop-filter: blur(20px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .mobile-nav.open {
      display: flex;
    }

    /* Hero Section */
    .hero {
      /* Use a mobile-friendly viewport height. We set --vh in JS to account for mobile browser UI chrome.
         Fallback to 100vh where custom property isn't available. */
      min-height: calc(var(--vh, 1vh) * 100);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      padding-top: 5rem;
    }

    .hero-content {
      text-align: center;
      position: relative;
      z-index: 20; /* raise hero content above canvas on mobile */
      max-width: 4xl;
    }

    .hero-subtitle {
      font-size: 0.875rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--primary);
      margin-bottom: 1.5rem;
      opacity: 0;
      animation: fadeIn 1s ease-out 0.5s forwards;
    }

    .hero-title {
      font-size: clamp(2.5rem, 8vw, 4.5rem);
      font-weight: bold;
      margin-bottom: 1.5rem;
      opacity: 0;
      animation: fadeIn 1s ease-out 1s forwards;
    }

    .hero-title .primary {
      color: var(--primary);
    }

    .primary {
      color: var(--primary);
    }

    .hero-description {
      font-size: 1.125rem;
      color: var(--muted-foreground);
      margin-bottom: 3rem;
      max-width: 32rem;
      margin-left: auto;
      margin-right: auto;
      opacity: 0;
      animation: fadeIn 1s ease-out 1.5s forwards;
    }

    .hero-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      justify-content: center;
      margin-bottom: 3rem;
      opacity: 0;
      animation: fadeIn 1s ease-out 2s forwards;
    }

    .btn-primary {
      background: var(--primary);
      color: var(--primary-foreground);
      border: none;
      padding: 0.75rem 2rem;
      border-radius: var(--radius);
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s;
    }

    .btn-primary:hover {
      background: hsl(188, 95%, 45%);
      box-shadow: 0 0 30px hsla(188, 95%, 50%, 0.5);
    }

    .btn-outline {
      background: transparent;
      color: var(--primary);
      border: 1px solid var(--primary);
      padding: 0.75rem 2rem;
      border-radius: var(--radius);
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s;
    }

    .btn-outline:hover {
      background: hsla(188, 95%, 50%, 0.1);
    }

    .hero-social {
      display: flex;
      gap: 1.5rem;
      justify-content: center;
      opacity: 0;
      animation: fadeIn 1s ease-out 2.5s forwards;
    }

    .social-link {
      color: var(--muted-foreground);
      transition: color 0.3s;
    }

    .social-link:hover {
      color: var(--primary);
    }

    .scroll-indicator {
      position: absolute;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      animation: bounce 2s infinite;
    }

    .scroll-indicator-inner {
      width: 1.5rem;
      height: 2.5rem;
      border: 2px solid var(--primary);
      border-radius: 1.25rem;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding: 0.5rem;
    }

    .scroll-dot {
      width: 0.25rem;
      height: 0.75rem;
      background: var(--primary);
      border-radius: 0.125rem;
    }

    /* Section Styles */
    .section {
      padding: 5rem 0;
    }

    .section-alt {
      background: hsla(220, 20%, 15%, 0.3);
    }

    .section-title {
      font-size: clamp(2rem, 6vw, 3rem);
      font-weight: bold;
      text-align: center;
      margin-bottom: 4rem;
    }

    .section-title .primary {
      color: var(--primary);
    }

    /* Card Styles */
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 2rem;
      transition: all 0.3s;
    }

    .card:hover {
      border-color: var(--primary);
      box-shadow: 0 0 30px hsla(188, 95%, 50%, 0.2);
    }

    /* Grid Layouts */
    .grid {
      display: grid;
      gap: 2rem;
    }

    .grid-2 {
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    }

    .grid-3 {
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    }

    /* About Section */
    .about-content {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 3rem;
      align-items: center;
      margin-bottom: 4rem;
    }

    .about-image {
      display: flex;
      justify-content: center;
    }

    .profile-image {
      width: 16rem;
      height: 16rem;
      border-radius: 1rem;
      border: 2px solid hsla(188, 95%, 50%, 0.5);
      object-fit: cover;
      transition: border-color 0.3s;
    }

    .profile-image:hover {
      border-color: var(--primary);
    }

    .about-text {
      font-size: 1.125rem;
      color: var(--muted-foreground);
      margin-bottom: 1.5rem;
    }

    .skill-card-icon {
      color: var(--primary);
      margin-bottom: 1rem;
    }

    .skill-card-title {
      font-size: 1.25rem;
      font-weight: bold;
      margin-bottom: 0.75rem;
    }

    .skill-card-description {
      color: var(--muted-foreground);
    }

    /* Projects Section */
    .project-filters {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 1rem;
      margin-bottom: 3rem;
    }

    .filter-button {
      padding: 0.5rem 1.5rem;
      border-radius: 2rem;
      border: none;
      cursor: pointer;
      transition: all 0.3s;
      background: var(--secondary);
      color: var(--foreground);
    }

    .filter-button.active {
      background: var(--primary);
      color: var(--primary-foreground);
      box-shadow: 0 0 20px hsla(188, 95%, 50%, 0.5);
    }

    .filter-button:hover {
      background: hsla(220, 20%, 12%, 0.8);
    }

    .filter-button.active:hover {
      background: hsl(188, 95%, 45%);
    }

    .project-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
      position: relative;
    }

    .project-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, 
        hsla(188, 95%, 50%, 0), 
        hsla(188, 95%, 50%, 0.1)
      );
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 1;
    }

    .project-card:hover {
      border-color: var(--primary);
      box-shadow: 
        0 15px 40px rgba(0, 0, 0, 0.3),
        0 0 30px hsla(188, 95%, 50%, 0.2);
      transform: translateY(-8px) scale(1.02);
    }

    .project-card:hover::before {
      opacity: 1;
    }

    .project-card:hover .project-image {
      transform: scale(1.1) rotate(1deg);
    }

    .project-image {
      width: 100%;
      height: 12rem;
      object-fit: cover;
      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .project-content {
      padding: 1.5rem;
    }

    .project-title {
      font-size: 1.25rem;
      font-weight: bold;
      margin-bottom: 0.5rem;
    }

    .project-description {
      color: var(--muted-foreground);
      margin-bottom: 1rem;
    }

    .project-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .tag {
      background: transparent;
      color: var(--primary);
      border: 1px solid hsla(188, 95%, 50%, 0.5);
      padding: 0.25rem 0.75rem;
      border-radius: var(--radius);
      font-size: 0.875rem;
    }

    .category-badge {
      background: linear-gradient(135deg, 
        hsla(188, 95%, 50%, 0.9), 
        hsla(188, 95%, 45%, 0.9)
      );
      color: var(--primary-foreground);
      padding: 0.5rem 1rem;
      border-radius: 2rem;
      font-size: 0.875rem;
      font-weight: 600;
      position: absolute;
      top: 1rem;
      left: 1rem;
      backdrop-filter: blur(10px);
      border: 1px solid hsla(188, 95%, 50%, 0.3);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      animation: badgeFloat 3s ease-in-out infinite;
      z-index: 2;
    }

    @keyframes badgeFloat {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-3px); }
    }

    /* Pagination Styles */
    .pagination {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      margin-top: 3rem;
      flex-wrap: wrap;
    }

    .pagination-btn {
      background: var(--card);
      border: 1px solid var(--border);
      color: var(--foreground);
      padding: 0.75rem 1rem;
      border-radius: var(--radius);
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
    }

    .pagination-btn:hover {
      background: var(--primary);
      color: var(--primary-foreground);
      border-color: var(--primary);
    }

    .pagination-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .pagination-btn:disabled:hover {
      background: var(--card);
      color: var(--foreground);
      border-color: var(--border);
    }

    .page-numbers {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .page-number {
      background: var(--card);
      border: 1px solid var(--border);
      color: var(--foreground);
      padding: 0.5rem 0.75rem;
      border-radius: var(--radius);
      cursor: pointer;
      transition: all 0.3s;
      font-size: 0.875rem;
      min-width: 2.5rem;
      text-align: center;
    }

    .page-number:hover {
      background: var(--secondary);
      border-color: var(--primary);
    }

    .page-number.active {
      background: var(--primary);
      color: var(--primary-foreground);
      border-color: var(--primary);
    }

    .page-ellipsis {
      color: var(--muted-foreground);
      padding: 0.5rem 0.25rem;
      font-size: 0.875rem;
    }

    @media (max-width: 768px) {
      .pagination {
        gap: 0.5rem;
        margin-top: 2rem;
      }

      .pagination-btn {
        padding: 0.5rem 0.75rem;
        font-size: 0.75rem;
      }

      .page-number {
        padding: 0.375rem 0.5rem;
        font-size: 0.75rem;
        min-width: 2rem;
      }
    }

    /* Skills Section */
    .skill-progress {
      margin-bottom: 1.5rem;
    }

    .skill-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
    }

    .skill-name {
      font-weight: 500;
    }

    .skill-level {
      color: var(--primary);
    }

    .progress-bar {
      height: 0.5rem;
      background: var(--secondary);
      border-radius: 0.25rem;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: var(--primary);
      border-radius: 0.25rem;
      transition: width 1s ease-out;
    }

    .tools-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      justify-content: center;
    }

    .tool-tag {
      background: var(--secondary);
      color: var(--foreground);
      padding: 0.5rem 1rem;
      border-radius: var(--radius);
      font-size: 0.875rem;
      transition: all 0.3s;
      cursor: pointer;
    }

    .tool-tag:hover {
      background: var(--primary);
      color: var(--primary-foreground);
    }

    /* Contact Section */
    .contact-content {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 3rem;
    }

    .contact-info {
      display: flex;
      align-items: flex-start;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .contact-icon {
      width: 3rem;
      height: 3rem;
      border-radius: var(--radius);
      background: hsla(188, 95%, 50%, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--primary);
      flex-shrink: 0;
    }

    .contact-form {
      background: hsla(34, 40, 56, 0.5);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 2rem;
    }

    .form-group {
      margin-bottom: 1.5rem;
    }

    .form-label {
      display: block;
      font-size: 0.875rem;
      font-weight: 500;
      margin-bottom: 0.5rem;
    }

    .form-input {
      width: 100%;
      padding: 0.75rem;
      background: hsla(220, 25%, 8%, 0.5);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      color: var(--foreground);
      font-size: 1rem;
    }

    .form-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 2px hsla(188, 95%, 50%, 0.2);
    }

    .form-textarea {
      min-height: 8rem;
      resize: vertical;
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: #10b981;
    }

    .status-dot {
      width: 0.5rem;
      height: 0.5rem;
      background: #10b981;
      border-radius: 50%;
    }

    /* Canvas Styles */
    .canvas-bg {
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: 0.3;
      z-index: 0; /* keep canvas background behind content */
    }

    .canvas-trail {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0; /* keep trail behind most UI elements; nav uses 50 */
      mix-blend-mode: screen;
    }

    /* Animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(2rem);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes bounce {

      0%,
      20%,
      53%,
      80%,
      100% {
        transform: translateX(-50%) translateY(0);
      }

      40%,
      43% {
        transform: translateX(-50%) translateY(-1rem);
      }

      70% {
        transform: translateX(-50%) translateY(-0.5rem);
      }

      90% {
        transform: translateX(-50%) translateY(-0.25rem);
      }
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .nav-links {
        display: none;
      }

      .mobile-menu-button {
        display: block;
      }

      .hero {
        padding-top: 8rem;
        padding-left: 1rem;
        padding-right: 1rem;
      }

      .hero-subtitle {
        font-size: 0.75rem;
        margin-bottom: 1rem;
      }

      .hero-title {
        font-size: clamp(2rem, 6vw, 3rem);
        margin-bottom: 1rem;
        line-height: 1.2;
      }

      .hero-description {
        font-size: 1rem;
        margin-bottom: 2rem;
        padding: 0 1rem;
      }

      .hero-buttons {
        flex-direction: column;
        align-items: center;
        gap: 1rem;
      }

      .btn-primary,
      .btn-outline {
        width: 100%;
        max-width: 280px;
        padding: 0.75rem 1.5rem;
      }

      .about-content {
        text-align: center;
      }

      .contact-content {
        grid-template-columns: 1fr;
      }

      .scroll-indicator {
        bottom: 0.1rem;
      }

      .hero-social {
        margin-bottom: 4rem;
        margin-top: 2rem;
      }
    }

    /* Utility Classes */
    .text-center {
      text-align: center;
    }

    .mb-1 {
      margin-bottom: 0.25rem;
    }

    .mb-2 {
      margin-bottom: 0.5rem;
    }

    .mb-3 {
      margin-bottom: 0.75rem;
    }

    .mb-4 {
      margin-bottom: 1rem;
    }

    .mb-6 {
      margin-bottom: 1.5rem;
    }

    .mb-8 {
      margin-bottom: 2rem;
    }

    .mb-12 {
      margin-bottom: 3rem;
    }

    .mt-4 {
      margin-top: 1rem;
    }

    .relative {
      position: relative;
    }

    .font-bold {
      font-weight: bold;
    }

    .font-semibold {
      font-weight: 600;
    }

    .text-sm {
      font-size: 0.875rem;
    }

    .text-lg {
      font-size: 1.125rem;
    }

    .text-xl {
      font-size: 1.25rem;
    }

    .text-2xl {
      font-size: 1.5rem;
    }

    .hidden {
      display: none;
    }

    /* Project Modal Styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0);
      backdrop-filter: blur(0px);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      opacity: 0;
      visibility: hidden;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .modal-overlay.active {
      opacity: 1;
      visibility: visible;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(12px);
    }

    .modal {
      background: linear-gradient(145deg, 
        hsla(220, 25%, 10%, 0.95), 
        hsla(220, 25%, 12%, 0.98),
        hsla(220, 25%, 8%, 0.95)
      );
      border: 2px solid hsla(188, 95%, 50%, 0.4);
      border-radius: 1.5rem;
      max-width: 90vw;
      max-height: 90vh;
      width: 950px;
      overflow: hidden;
      position: relative;
      transform: scale(0.7) translateY(50px) rotateX(15deg);
      transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
      box-shadow: 
        0 30px 60px rgba(0, 0, 0, 0.6),
        0 0 80px hsla(188, 95%, 50%, 0.15),
        inset 0 1px 0 hsla(188, 95%, 50%, 0.2),
        inset 0 -1px 0 hsla(188, 95%, 50%, 0.1);
      perspective: 1000px;
      backdrop-filter: blur(20px);
    }

    .modal-overlay.active .modal {
      transform: scale(1) translateY(0) rotateX(0deg);
    }

    .modal::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, 
        transparent,
        hsla(188, 95%, 60%, 0.8),
        var(--primary),
        hsla(188, 95%, 40%, 0.8),
        transparent
      );
      animation: shimmer 3s ease-in-out infinite;
    }

    .modal::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(
        circle at 50% 0%,
        hsla(188, 95%, 50%, 0.1) 0%,
        transparent 50%
      );
      pointer-events: none;
      border-radius: 1.5rem;
    }

    @keyframes shimmer {
      0%, 100% { 
        opacity: 0.4;
        transform: translateX(-100%);
      }
      50% { 
        opacity: 1;
        transform: translateX(0%);
      }
    }

    .modal-header {
      padding: 2.5rem;
      border-bottom: 2px solid hsla(188, 95%, 50%, 0.3);
      position: sticky;
      top: 0;
      background: linear-gradient(135deg, 
        hsla(220, 25%, 10%, 0.98), 
        hsla(220, 25%, 12%, 0.98),
        hsla(220, 25%, 8%, 0.95)
      );
      backdrop-filter: blur(25px);
      z-index: 10;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-radius: 1.5rem 1.5rem 0 0;
      position: relative;
    }

    .modal-header::before {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg,
        transparent,
        hsla(188, 95%, 50%, 0.6),
        var(--primary),
        hsla(188, 95%, 50%, 0.6),
        transparent
      );
    }

    .modal-title {
      font-size: 2rem;
      font-weight: bold;
      margin: 0;
      background: linear-gradient(135deg, 
        var(--foreground), 
        var(--primary),
        hsla(188, 95%, 60%, 1),
        var(--primary),
        var(--foreground)
      );
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      background-size: 200% 100%;
      animation: titleGlow 4s ease-in-out infinite alternate,
                 titleShift 6s ease-in-out infinite;
      text-shadow: 0 0 30px hsla(188, 95%, 50%, 0.3);
    }

    @keyframes titleGlow {
      0% { filter: drop-shadow(0 0 8px hsla(188, 95%, 50%, 0.4)); }
      100% { filter: drop-shadow(0 0 20px hsla(188, 95%, 50%, 0.8)); }
    }

    @keyframes titleShift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .modal-close {
      background: linear-gradient(135deg, 
        hsla(220, 25%, 15%, 0.9),
        hsla(220, 25%, 18%, 0.9),
        hsla(220, 25%, 12%, 0.9)
      );
      border: 2px solid hsla(188, 95%, 50%, 0.4);
      color: var(--foreground);
      cursor: pointer;
      padding: 1rem;
      border-radius: 50%;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(10px);
    }

    .modal-close::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: radial-gradient(
        circle,
        hsla(188, 95%, 50%, 0.3),
        hsla(188, 95%, 50%, 0.1),
        transparent
      );
      transition: all 0.4s ease;
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }

    .modal-close::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      background: conic-gradient(
        from 0deg,
        transparent,
        hsla(188, 95%, 50%, 0.2),
        transparent,
        hsla(188, 95%, 50%, 0.2),
        transparent
      );
      opacity: 0;
      transition: all 0.4s ease;
      animation: rotateGlow 4s linear infinite;
    }

    @keyframes rotateGlow {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .modal-close:hover {
      background: linear-gradient(135deg, 
        hsla(188, 95%, 50%, 0.2),
        hsla(188, 95%, 45%, 0.3),
        hsla(188, 95%, 50%, 0.2)
      );
      border-color: hsla(188, 95%, 50%, 0.8);
      transform: rotate(90deg) scale(1.15);
      box-shadow: 
        0 0 25px hsla(188, 95%, 50%, 0.4),
        inset 0 0 15px hsla(188, 95%, 50%, 0.1);
    }

    .modal-close:hover::before {
      width: 120%;
      height: 120%;
    }

    .modal-close:hover::after {
      opacity: 1;
    }

    .modal-close:active {
      transform: rotate(90deg) scale(0.95);
    }

    .modal-content {
      padding: 2rem;
      overflow-y: auto;
      max-height: calc(90vh - 120px);
      background: linear-gradient(145deg, 
        hsla(220, 25%, 8%, 0.3), 
        hsla(220, 25%, 12%, 0.3)
      );
      position: relative;
    }

    /* Enhanced Custom Scrollbar for PC */
    .modal-content::-webkit-scrollbar {
      width: 14px;
      background: transparent;
    }

    .modal-content::-webkit-scrollbar-track {
      background: linear-gradient(180deg, 
        hsla(220, 25%, 8%, 0.3), 
        hsla(220, 25%, 12%, 0.5),
        hsla(220, 25%, 8%, 0.3)
      );
      border-radius: 10px;
      border: 1px solid hsla(188, 95%, 50%, 0.1);
      box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
    }

    .modal-content::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, 
        hsla(188, 95%, 50%, 0.8),
        hsla(188, 95%, 45%, 0.9),
        hsla(188, 95%, 40%, 1),
        hsla(188, 95%, 45%, 0.9),
        hsla(188, 95%, 50%, 0.8)
      );
      border-radius: 10px;
      border: 1px solid hsla(188, 95%, 50%, 0.4);
      box-shadow: 
        0 0 10px hsla(188, 95%, 50%, 0.4),
        inset 0 1px 0 hsla(188, 95%, 60%, 0.3),
        inset 0 -1px 0 hsla(188, 95%, 30%, 0.3);
      position: relative;
    }

    .modal-content::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, 
        hsla(188, 95%, 55%, 0.9),
        hsla(188, 95%, 50%, 1),
        hsla(188, 95%, 45%, 1),
        hsla(188, 95%, 50%, 1),
        hsla(188, 95%, 55%, 0.9)
      );
      box-shadow: 
        0 0 15px hsla(188, 95%, 50%, 0.6),
        inset 0 1px 0 hsla(188, 95%, 65%, 0.4),
        inset 0 -1px 0 hsla(188, 95%, 25%, 0.4);
      border-color: hsla(188, 95%, 50%, 0.6);
    }

    .modal-content::-webkit-scrollbar-thumb:active {
      background: linear-gradient(180deg, 
        hsla(188, 95%, 60%, 1),
        hsla(188, 95%, 55%, 1),
        hsla(188, 95%, 50%, 1),
        hsla(188, 95%, 55%, 1),
        hsla(188, 95%, 60%, 1)
      );
      box-shadow: 
        0 0 20px hsla(188, 95%, 50%, 0.8),
        inset 0 2px 4px hsla(188, 95%, 30%, 0.5);
    }

    .modal-content::-webkit-scrollbar-corner {
      background: transparent;
    }

    /* Animated scroll indicators */
    .modal-content::before {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: 14px;
      height: 30px;
      background: linear-gradient(180deg, 
        hsla(188, 95%, 50%, 0.3),
        transparent
      );
      border-radius: 0 0 10px 10px;
      pointer-events: none;
      z-index: 5;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .modal-content::after {
      content: '';
      position: absolute;
      bottom: 0;
      right: 0;
      width: 14px;
      height: 30px;
      background: linear-gradient(0deg, 
        hsla(188, 95%, 50%, 0.3),
        transparent
      );
      border-radius: 10px 10px 0 0;
      pointer-events: none;
      z-index: 5;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .modal-content:hover::before,
    .modal-content:hover::after {
      opacity: 1;
    }

    .modal-tabs {
      display: flex;
      gap: 1rem;
      margin-bottom: 2rem;
      border-bottom: 2px solid hsla(188, 95%, 50%, 0.2);
      padding-bottom: 1rem;
      background: linear-gradient(135deg, 
        hsla(220, 25%, 15%, 0.4),
        hsla(220, 25%, 18%, 0.4),
        hsla(220, 25%, 12%, 0.4)
      );
      border-radius: 1rem 1rem 0 0;
      padding: 1.5rem 1.5rem 1rem 1.5rem;
      position: relative;
      backdrop-filter: blur(10px);
    }

    .modal-tabs::before {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg,
        transparent,
        hsla(188, 95%, 50%, 0.4),
        var(--primary),
        hsla(188, 95%, 50%, 0.4),
        transparent
      );
    }

    .modal-tab {
      background: transparent;
      border: 2px solid hsla(188, 95%, 50%, 0.2);
      color: var(--muted-foreground);
      cursor: pointer;
      padding: 1rem 2rem;
      border-radius: 0.75rem;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      font-size: 1rem;
      font-weight: 600;
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(5px);
    }

    .modal-tab::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
        transparent, 
        hsla(188, 95%, 50%, 0.15), 
        transparent
      );
      transition: left 0.6s ease;
    }

    .modal-tab::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      width: 0;
      height: 2px;
      background: var(--primary);
      transition: all 0.4s ease;
      transform: translateX(-50%);
    }

    .modal-tab:hover::before {
      left: 100%;
    }

    .modal-tab.active {
      color: var(--primary);
      background: linear-gradient(135deg,
        hsla(188, 95%, 50%, 0.15),
        hsla(188, 95%, 45%, 0.1),
        hsla(188, 95%, 50%, 0.15)
      );
      border-color: hsla(188, 95%, 50%, 0.5);
      box-shadow: 
        0 0 25px hsla(188, 95%, 50%, 0.3),
        inset 0 1px 0 hsla(188, 95%, 50%, 0.3);
      transform: translateY(-3px);
    }

    .modal-tab.active::after {
      width: 80%;
    }

    .modal-tab:hover {
      color: var(--primary);
      background: hsla(188, 95%, 50%, 0.08);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    .tab-content {
      display: none;
      animation: fadeInUp 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .tab-content.active {
      display: block;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
        transform: translateY(0);
      }
      to {
        opacity: 0;
        transform: translateY(-10px);
      }
    }

    @keyframes fadeInScale {
      from {
        opacity: 0;
        transform: scale(0.8);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    @keyframes fadeInLeft {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    @keyframes particleFloat {
      0%, 100% {
        transform: translateY(0) rotate(0deg);
        opacity: 0.3;
      }
      25% {
        transform: translateY(-20px) rotate(90deg);
        opacity: 1;
      }
      50% {
        transform: translateY(-10px) rotate(180deg);
        opacity: 0.7;
      }
      75% {
        transform: translateY(-30px) rotate(270deg);
        opacity: 1;
      }
    }

    .project-detail-image {
      width: 100%;
      height: 400px;
      object-fit: cover;
      border-radius: 1.25rem;
      margin-bottom: 2rem;
      border: 2px solid hsla(188, 95%, 50%, 0.3);
      transition: all 0.4s ease;
      box-shadow: 
        0 15px 35px rgba(0, 0, 0, 0.4),
        0 0 25px hsla(188, 95%, 50%, 0.1);
      position: relative;
      overflow: hidden;
    }

    .project-detail-image::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(
        135deg,
        hsla(188, 95%, 50%, 0) 0%,
        hsla(188, 95%, 50%, 0.1) 50%,
        hsla(188, 95%, 50%, 0) 100%
      );
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .project-detail-image:hover {
      border-color: var(--primary);
      box-shadow: 
        0 20px 45px rgba(0, 0, 0, 0.5),
        0 0 40px hsla(188, 95%, 50%, 0.3);
      transform: translateY(-8px) scale(1.02);
    }

    .project-detail-image:hover::before {
      opacity: 1;
    }

    .project-detail-image::after {
      content: '�️ Click for full view';
      position: absolute;
      bottom: 1rem;
      right: 1rem;
      background: linear-gradient(135deg, 
        hsla(188, 95%, 50%, 0.9), 
        hsla(188, 95%, 45%, 0.9)
      );
      color: white;
      padding: 0.75rem 1.25rem;
      border-radius: 2rem;
      font-size: 0.875rem;
      font-weight: 600;
      opacity: 0;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: none;
      backdrop-filter: blur(15px);
      border: 1px solid hsla(188, 95%, 50%, 0.3);
      box-shadow: 
        0 8px 25px rgba(0, 0, 0, 0.3),
        0 0 20px hsla(188, 95%, 50%, 0.2);
      transform: translateY(10px) scale(0.9);
    }

    .project-detail-image:hover::after {
      opacity: 1;
      transform: translateY(0) scale(1);
    }

    .image-gallery {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 2rem;
      margin-bottom: 2rem;
    }

    .gallery-image {
      width: 100%;
      height: 200px;
      object-fit: cover;
      border-radius: 1rem;
      cursor: pointer;
      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      border: 2px solid hsla(188, 95%, 50%, 0.2);
      position: relative;
      overflow: hidden;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
    }

    .gallery-image::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(45deg, 
        transparent 30%, 
        hsla(188, 95%, 50%, 0.15) 50%,
        transparent 70%
      );
      opacity: 0;
      transition: all 0.4s ease;
      transform: translateX(-100%);
    }

    .gallery-image::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(
        circle at center,
        hsla(188, 95%, 50%, 0.1) 0%,
        transparent 70%
      );
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .gallery-image:hover {
      transform: scale(1.08) rotateY(8deg) rotateX(2deg);
      border-color: var(--primary);
      box-shadow: 
        0 20px 40px rgba(0, 0, 0, 0.4),
        0 0 30px hsla(188, 95%, 50%, 0.3);
    }

    .gallery-image:hover::before {
      opacity: 1;
      transform: translateX(100%);
    }

    .gallery-image:hover::after {
      opacity: 1;
    }

    .video-container {
      width: 100%;
      height: 0;
      padding-bottom: 56.25%; /* 16:9 aspect ratio */
      background: linear-gradient(135deg, var(--secondary), hsl(220, 25%, 18%));
      border-radius: 1rem;
      position: relative;
      margin-bottom: 1.5rem;
      border: 2px solid hsla(188, 95%, 50%, 0.2);
      overflow: hidden;
    }

    .video-container iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: none;
      border-radius: 1rem;
    }

    .video-fullscreen-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border: none;
      border-radius: 5px;
      padding: 8px 12px;
      cursor: pointer;
      z-index: 10;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .video-container:hover .video-fullscreen-btn {
      opacity: 1;
    }

    .video-fullscreen-btn:hover {
      background: rgba(0, 0, 0, 0.9);
    }

    /* Fullscreen video styles */
    .video-fullscreen {
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      width: 100vw !important;
      height: 100vh !important;
      z-index: 9999 !important;
      background: black !important;
    }

    .video-fullscreen iframe {
      border-radius: 0 !important;
    }

    .video-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
        transparent, 
        hsla(188, 95%, 50%, 0.1), 
        transparent
      );
      animation: videoShimmer 3s ease-in-out infinite;
    }

    @keyframes videoShimmer {
      0%, 100% { left: -100%; }
      50% { left: 100%; }
    }

    .video-placeholder {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: var(--muted-foreground);
      z-index: 2;
      width: 100%;
    }

    .video-placeholder svg {
      color: var(--primary);
      margin-bottom: 1rem;
      filter: drop-shadow(0 0 10px hsla(188, 95%, 50%, 0.3));
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .code-block {
      background: linear-gradient(135deg, 
        hsla(220, 25%, 8%, 0.9), 
        hsla(220, 25%, 12%, 0.9)
      );
      border: 1px solid hsla(188, 95%, 50%, 0.2);
      border-radius: 1rem;
      padding: 0;
      margin-bottom: 2rem;
      overflow: hidden;
      transition: all 0.3s ease;
      position: relative;
    }

    .code-block::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, 
        transparent, 
        var(--primary), 
        transparent
      );
    }

    .code-block:hover {
      border-color: var(--primary);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      transform: translateY(-2px);
    }

    .code-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      background: hsla(220, 25%, 15%, 0.8);
      border-bottom: 1px solid hsla(188, 95%, 50%, 0.1);
    }

    .code-language {
      font-size: 0.875rem;
      color: var(--primary);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .copy-button {
      background: linear-gradient(135deg, var(--primary), hsl(188, 95%, 45%));
      color: var(--primary-foreground);
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-weight: 500;
      position: relative;
      overflow: hidden;
    }

    .copy-button::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      transition: all 0.3s ease;
      transform: translate(-50%, -50%);
    }

    .copy-button:hover {
      background: linear-gradient(135deg, hsl(188, 95%, 45%), hsl(188, 95%, 40%));
      box-shadow: 0 5px 15px hsla(188, 95%, 50%, 0.4);
      transform: translateY(-1px);
    }

    .copy-button:hover::before {
      width: 100%;
      height: 100%;
    }

    .copy-button:active {
      transform: translateY(0);
    }

    .code-content {
      font-family: 'Fira Code', 'Courier New', monospace;
      font-size: 0.875rem;
      line-height: 1.6;
      color: var(--foreground);
      white-space: pre-wrap;
      padding: 1.5rem;
      background: hsla(220, 25%, 10%, 0.5);
      overflow-x: auto;
    }

    .project-links {
      display: flex;
      gap: 1rem;
      margin-top: 2rem;
      animation: slideInUp 0.6s ease-out 0.3s both;
    }

    @keyframes slideInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .project-link {
      background: linear-gradient(135deg, var(--primary), hsl(188, 95%, 45%));
      color: var(--primary-foreground);
      border: none;
      padding: 1rem 2rem;
      border-radius: 0.75rem;
      text-decoration: none;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      gap: 0.75rem;
      position: relative;
      overflow: hidden;
      border: 1px solid transparent;
    }

    .project-link::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
        transparent, 
        rgba(255, 255, 255, 0.2), 
        transparent
      );
      transition: left 0.6s ease;
    }

    .project-link:hover::before {
      left: 100%;
    }

    .project-link:hover {
      background: linear-gradient(135deg, hsl(188, 95%, 45%), hsl(188, 95%, 40%));
      box-shadow: 
        0 10px 25px hsla(188, 95%, 50%, 0.4),
        0 0 40px hsla(188, 95%, 50%, 0.2);
      transform: translateY(-3px) scale(1.05);
    }

    .project-link.secondary {
      background: transparent;
      color: var(--primary);
      border: 2px solid var(--primary);
      position: relative;
    }

    .project-link.secondary::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--primary);
      transform: scaleX(0);
      transform-origin: left;
      transition: transform 0.3s ease;
      z-index: -1;
    }

    .project-link.secondary:hover {
      color: var(--primary-foreground);
      background: transparent;
      transform: translateY(-3px) scale(1.05);
    }

    .project-link.secondary:hover::after {
      transform: scaleX(1);
    }

    .project-link svg {
      transition: transform 0.3s ease;
    }

    .project-link:hover svg {
      transform: translateX(3px);
    }

    @media (max-width: 768px) {
      /* Enhanced Mobile Modal Styles */
      .modal-overlay {
        padding: 0;
        align-items: flex-start;
        overflow-y: auto;
      }

      .modal {
        width: 100vw;
        max-width: none;
        max-height: none;
        min-height: 100vh;
        margin: 0;
        border-radius: 0;
        transform: translateY(100%);
        transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: none;
      }

      .modal-overlay.active .modal {
        transform: translateY(0);
      }

      .modal-header {
        padding: 1rem 1.5rem;
        position: sticky;
        top: 0;
        z-index: 20;
        border-radius: 0;
        backdrop-filter: blur(20px);
        background: linear-gradient(135deg, 
          hsla(220, 25%, 10%, 0.98), 
          hsla(220, 25%, 12%, 0.98)
        );
      }

      .modal-title {
        font-size: 1.25rem;
        line-height: 1.3;
        margin-right: 1rem;
      }

      .modal-close {
        padding: 0.5rem;
        width: 40px;
        height: 40px;
        min-width: 40px;
        border-radius: 50%;
      }

      .modal-content {
        padding: 1rem 1.5rem 2rem;
        max-height: none;
        overflow-y: visible;
        background: var(--background);
      }

      /* Mobile Tabs */
      .modal-tabs {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.5rem;
        margin-bottom: 1.5rem;
        padding: 0.75rem;
        background: hsla(220, 25%, 15%, 0.7);
        border-radius: 0.75rem;
        border: 1px solid hsla(188, 95%, 50%, 0.1);
      }

      .modal-tab {
        padding: 0.75rem 0.5rem;
        font-size: 0.875rem;
        text-align: center;
        border-radius: 0.5rem;
        font-weight: 600;
        min-height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .modal-tab.active {
        transform: none;
        background: hsla(188, 95%, 50%, 0.15);
        border-color: hsla(188, 95%, 50%, 0.4);
      }

      /* Overview Tab Mobile */
      .project-detail-image {
        height: 220px;
        margin-bottom: 1.25rem;
        border-radius: 0.75rem;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      }

      #modalDescription {
        font-size: 1rem;
        line-height: 1.6;
        margin-bottom: 1.25rem;
        text-align: left;
      }

      #modalTags {
        margin-bottom: 1.5rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      #modalTags .tag {
        font-size: 0.75rem;
        padding: 0.375rem 0.75rem;
        border-radius: 1rem;
        border: 1px solid hsla(188, 95%, 50%, 0.3);
        background: hsla(188, 95%, 50%, 0.1);
      }

      #modalFeatures {
        background: hsla(220, 25%, 15%, 0.5);
        border-radius: 0.75rem;
        padding: 1.25rem;
        margin-bottom: 1.5rem;
        border: 1px solid hsla(188, 95%, 50%, 0.1);
      }

      #modalFeatures h4 {
        font-size: 1.125rem;
        margin-bottom: 1rem;
        color: var(--primary);
      }

      #modalFeatures ul {
        margin-left: 0;
        list-style: none;
      }

      #modalFeatures li {
        font-size: 0.875rem;
        margin-bottom: 0.75rem;
        line-height: 1.5;
        padding-left: 1.5rem;
        position: relative;
      }

      #modalFeatures li::before {
        content: '✓';
        position: absolute;
        left: 0;
        color: var(--primary);
        font-weight: bold;
      }

      /* Project Links Mobile */
      .project-links {
        flex-direction: column;
        gap: 1rem;
        margin-top: 1.5rem;
      }

      .project-link {
        width: 100%;
        justify-content: center;
        padding: 1rem;
        font-size: 1rem;
        border-radius: 0.75rem;
        min-height: 48px;
      }

      /* Images Tab Mobile */
      .image-gallery {
        grid-template-columns: 1fr;
        gap: 1.25rem;
      }

      .gallery-image {
        height: 220px;
        border-radius: 0.75rem;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
      }

      .gallery-image:hover {
        transform: scale(1.02);
      }

      /* Videos Tab Mobile */
      .video-container {
        padding-bottom: 56.25%; /* Maintain 16:9 aspect ratio on mobile */
        margin-bottom: 1.25rem;
        border-radius: 0.75rem;
      }

      .video-container iframe {
        border-radius: 0.75rem;
      }

      .video-placeholder {
        padding: 1.5rem;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: calc(100% - 3rem);
      }

      .video-placeholder svg {
        width: 40px;
        height: 40px;
        margin-bottom: 1rem;
      }

      .video-placeholder p {
        font-size: 0.9rem;
        text-align: center;
        line-height: 1.5;
      }

      /* Code Tab Mobile */
      .code-block {
        margin-bottom: 1.5rem;
        border-radius: 0.75rem;
        overflow: hidden;
      }

      .code-header {
        padding: 1rem;
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
        background: hsla(220, 25%, 15%, 0.9);
      }

      .code-language {
        font-size: 0.8rem;
        font-weight: 700;
      }

      .copy-button {
        padding: 0.5rem 1rem;
        font-size: 0.75rem;
        border-radius: 0.5rem;
        min-height: 36px;
      }

      .code-content {
        padding: 1.25rem;
        font-size: 0.8rem;
        line-height: 1.6;
        overflow-x: auto;
        white-space: pre;
        background: hsla(220, 25%, 8%, 0.9);
      }

      /* Enhanced Mobile Scrollbar */
      .modal-content::-webkit-scrollbar {
        width: 4px;
      }

      .modal-content::-webkit-scrollbar-track {
        background: hsla(220, 25%, 15%, 0.5);
      }

      .modal-content::-webkit-scrollbar-thumb {
        background: var(--primary);
        border-radius: 2px;
      }
    }

    /* Mobile override for canvas positioning to avoid fixed-position issues on some mobile browsers */
    @media (max-width: 768px) {
      .canvas-trail,
      .canvas-bg {
        /* Fixed canvas can cause mispositioning or clipping on mobile — use absolute so it flows with viewport height. */
        position: absolute;
      }
    }
  </style>
</head>

<body>
  <!-- Mouse Trail Canvas -->
  <canvas id="mouseTrail" class="canvas-trail"></canvas>

  <!-- Fix mobile viewport height for full-screen sections: set --vh to 1% of the window.innerHeight -->
  <script>
    (function() {
      function setVh() {
        document.documentElement.style.setProperty('--vh', window.innerHeight * 0.01 + 'px');
      }
      setVh();
      window.addEventListener('resize', setVh);
    })();
  </script>

  <!-- Navigation -->
  <nav class="nav">
    <div class="container nav-content">
      <div class="nav-logo">AgSapaula</div>

      <div class="nav-links">
        <button class="nav-link" onclick="scrollToSection('about')">About</button>
        <button class="nav-link" onclick="scrollToSection('projects')">Projects</button>
        <button class="nav-link" onclick="scrollToSection('skills')">Skills</button>
        <button class="nav-button" onclick="scrollToSection('contact')">Get In Touch</button>
      </div>

      <button class="mobile-menu-button" onclick="toggleMobileMenu()">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="3" y1="6" x2="21" y2="6"></line>
          <line x1="3" y1="12" x2="21" y2="12"></line>
          <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
      </button>
    </div>

    <div id="mobileNav" class="mobile-nav">
      <button class="nav-link" onclick="scrollToSection('about')">About</button>
      <button class="nav-link" onclick="scrollToSection('projects')">Projects</button>
      <button class="nav-link" onclick="scrollToSection('skills')">Skills</button>
    </div>
  </nav>

  <!-- Hero Section -->
  <section class="hero">
    <canvas id="platformGame" class="canvas-bg"></canvas>

    <div class="container hero-content">
      <div class="hero-subtitle">Game Developer & Designer</div>

      <h1 class="hero-title">
        Crafting Immersive <br>
        <span class="primary">Gaming Experiences</span>
      </h1>

      <p class="hero-description">
        Passionate game developer specializing in 3D design, animation, and interactive gameplay.
        Transforming creative visions into engaging digital realities.
      </p>

      <div class="hero-buttons">
        <button class="btn-primary" onclick="scrollToSection('projects')">View My Work</button>
        <button class="btn-outline" onclick="scrollToSection('contact')">Get In Touch</button>
      </div>

      <div class="hero-social">
        <a href="https://github.com" target="_blank" class="social-link">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path
              d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z" />
          </svg>
        </a>
        <a href="https://linkedin.com" target="_blank" class="social-link">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path
              d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z" />
          </svg>
        </a>
        <a href="https://twitter.com" target="_blank" class="social-link">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path
              d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z" />
          </svg>
        </a>
        <a href="mailto:hello@gamedev.com" class="social-link">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
            <polyline points="22,6 12,13 2,6"></polyline>
          </svg>
        </a>
      </div>
    </div>

    <div class="scroll-indicator">
      <div class="scroll-indicator-inner">
        <div class="scroll-dot"></div>
      </div>
    </div>
  </section>

  <!-- About Section -->
  <section id="about" class="section">
    <div class="container">
      <h2 class="section-title">
        About <span class="primary">Me</span>
      </h2>

      <div class="about-content">
        <div class="about-image">
          <img src="https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=400&fit=crop&crop=face"
            alt="Profile" class="profile-image">
        </div>

        <div>
          <p class="about-text">
            Hi, I'm <span class="primary">Angelo Gabriel Sapaula</span>, a passionate game developer with expertise in creating immersive 3D experiences—from
            detailed modeling and fluid animation to fully playable, engaging games.
          </p>
          <p class="about-text">
            With extensive experience in project management and team leadership, I bring both technical
            skills and collaborative energy to every project. I thrive in dynamic environments and am
            always pushing myself to learn, grow, and deliver exceptional results.
          </p>
        </div>
      </div>

      <div class="grid grid-3">
        <div class="card">
          <div class="skill-card-icon">
            <svg width="32" height="32" viewBox="0 0 24 24" fill="currentColor">
              <path d="M2 12C2 12 7 7 12 7s10 5 10 5-5 5-10 5S2 12 2 12z" />
              <circle cx="12" cy="12" r="3" />
            </svg>
          </div>
          <h3 class="skill-card-title">Game Development</h3>
          <p class="skill-card-description">Expert in Unity and Unreal Engine, crafting engaging gameplay mechanics and
            systems.</p>
        </div>

        <div class="card">
          <div class="skill-card-icon">
            <svg width="32" height="32" viewBox="0 0 24 24" fill="currentColor">
              <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
            </svg>
          </div>
          <h3 class="skill-card-title">3D Design & Animation</h3>
          <p class="skill-card-description">Skilled in Blender for creating stunning models, textures, and character
            animations.</p>
        </div>

        <div class="card">
          <div class="skill-card-icon">
            <svg width="32" height="32" viewBox="0 0 24 24" fill="currentColor">
              <path
                d="M3 3h18v18H3V3zm16 16V5H5v14h14zM7 7h2v2H7V7zm4 0h2v2h-2V7zm4 0h2v2h-2V7zM7 11h2v2H7v-2zm4 0h6v2h-6v-2zM7 15h10v2H7v-2z" />
            </svg>
          </div>
          <h3 class="skill-card-title">Programming</h3>
          <p class="skill-card-description">Proficient in C#, C++, and Python for building robust game systems and
            tools.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- Projects Section -->
  <section id="projects" class="section section-alt">
    <div class="container">
      <h2 class="section-title">
        Featured <span class="primary">Projects</span>
      </h2>

      <div class="project-filters">
        <button class="filter-button active" onclick="filterProjects('All')">All</button>
        <button class="filter-button" onclick="filterProjects('Games')">Games</button>
        <button class="filter-button" onclick="filterProjects('3D Models')">3D Models</button>
        <button class="filter-button" onclick="filterProjects('Animations')">Animations</button>
      </div>

      <div id="projectsGrid" class="grid grid-3">
        <!-- Projects will be populated by JavaScript -->
      </div>
      
      <!-- Pagination -->
      <div id="pagination" class="pagination" style="display: none;">
        <button id="prevPage" class="pagination-btn" onclick="changePage(-1)">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="15,18 9,12 15,6"></polyline>
          </svg>
          Previous
        </button>
        <div id="pageNumbers" class="page-numbers"></div>
        <button id="nextPage" class="pagination-btn" onclick="changePage(1)">
          Next
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="9,18 15,12 9,6"></polyline>
          </svg>
        </button>
      </div>
    </div>
  </section>

  <!-- Project Modal -->
  <div id="projectModal" class="modal-overlay">
    <div class="modal">
      <div class="modal-header">
        <h2 id="modalTitle" class="modal-title">Project Title</h2>
        <button class="modal-close" onclick="closeProjectModal()">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      
      <div class="modal-content">
        <div class="modal-tabs">
          <button class="modal-tab active" onclick="switchTab('overview')">Overview</button>
          <button class="modal-tab" onclick="switchTab('images')">Images</button>
          <button class="modal-tab" onclick="switchTab('videos')">Videos</button>
          <button class="modal-tab" onclick="switchTab('code')">Code</button>
        </div>

        <!-- Overview Tab -->
        <div id="overviewTab" class="tab-content active">
          <img id="modalMainImage" src="" alt="" class="project-detail-image">
          <div id="modalDescriptionSection" class="mb-4">
            <h4 class="text-xl font-semibold mb-2" style="color: var(--primary);">Description:</h4>
            <p id="modalDescription" class="text-base" style="color: var(--muted-foreground);"></p>
          </div>
          <div id="modalContribution" class="mb-4" style="display: none;">
            <h4 class="text-xl font-semibold mb-2" style="color: var(--primary);">Contribution:</h4>
            <p class="text-base" style="color: var(--muted-foreground);"></p>
          </div>
          <div id="modalTags" class="project-tags mb-4"></div>
          <div id="modalFeatures"></div>
          <div class="project-links">
            <a href="#" class="project-link" id="liveDemoLink">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                <polyline points="15,3 21,3 21,9"></polyline>
                <line x1="10" y1="14" x2="21" y2="3"></line>
              </svg>
              Live Demo
            </a>
            <a href="#" class="project-link secondary" id="sourceCodeLink">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
              </svg>
              Source Code
            </a>
          </div>
        </div>

        <!-- Images Tab -->
        <div id="imagesTab" class="tab-content">
          <div id="imageGallery" class="image-gallery"></div>
        </div>

        <!-- Videos Tab -->
        <div id="videosTab" class="tab-content">
          <div id="videoContainer" class="video-container">
            <div class="video-placeholder">
              <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polygon points="5,3 19,12 5,21"></polygon>
              </svg>
              <p>Project demo video will be available soon</p>
            </div>
          </div>
          <p style="color: var(--muted-foreground);">Gameplay footage and development process videos showcase the project in action.</p>
        </div>

        <!-- Code Tab -->
        <div id="codeTab" class="tab-content">
          <div id="codeBlocks"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Skills Section -->
  <section id="skills" class="section">
    <div class="container">
      <h2 class="section-title">
        Technical <span class="primary">Skills</span>
      </h2>

      <div class="grid grid-2 mb-12">
        <div class="card">
          <h3 class="text-2xl font-bold mb-6">Game Engines</h3>
          <div class="skill-progress">
            <div class="skill-header">
              <span class="skill-name">Unity</span>
              <span class="skill-level">90%</span>
            </div>
            <div class="progress-bar">
              <div class="progress-fill" style="width: 90%"></div>
            </div>
          </div>
          <div class="skill-progress">
            <div class="skill-header">
              <span class="skill-name">Unreal Engine</span>
              <span class="skill-level">85%</span>
            </div>
            <div class="progress-bar">
              <div class="progress-fill" style="width: 85%"></div>
            </div>
          </div>
          <div class="skill-progress">
            <div class="skill-header">
              <span class="skill-name">Godot</span>
              <span class="skill-level">70%</span>
            </div>
            <div class="progress-bar">
              <div class="progress-fill" style="width: 70%"></div>
            </div>
          </div>
        </div>

        <div class="card">
          <h3 class="text-2xl font-bold mb-6">3D Software</h3>
          <div class="skill-progress">
            <div class="skill-header">
              <span class="skill-name">Blender</span>
              <span class="skill-level">95%</span>
            </div>
            <div class="progress-bar">
              <div class="progress-fill" style="width: 95%"></div>
            </div>
          </div>
          <div class="skill-progress">
            <div class="skill-header">
              <span class="skill-name">Maya</span>
              <span class="skill-level">80%</span>
            </div>
            <div class="progress-bar">
              <div class="progress-fill" style="width: 80%"></div>
            </div>
          </div>
          <div class="skill-progress">
            <div class="skill-header">
              <span class="skill-name">Substance Painter</span>
              <span class="skill-level">85%</span>
            </div>
            <div class="progress-bar">
              <div class="progress-fill" style="width: 85%"></div>
            </div>
          </div>
        </div>

        <div class="card">
          <h3 class="text-2xl font-bold mb-6">Programming</h3>
          <div class="skill-progress">
            <div class="skill-header">
              <span class="skill-name">C#</span>
              <span class="skill-level">90%</span>
            </div>
            <div class="progress-bar">
              <div class="progress-fill" style="width: 90%"></div>
            </div>
          </div>
          <div class="skill-progress">
            <div class="skill-header">
              <span class="skill-name">C++</span>
              <span class="skill-level">85%</span>
            </div>
            <div class="progress-bar">
              <div class="progress-fill" style="width: 85%"></div>
            </div>
          </div>
          <div class="skill-progress">
            <div class="skill-header">
              <span class="skill-name">Python</span>
              <span class="skill-level">80%</span>
            </div>
            <div class="progress-bar">
              <div class="progress-fill" style="width: 80%"></div>
            </div>
          </div>
        </div>

        <div class="card">
          <h3 class="text-2xl font-bold mb-6">Design</h3>
          <div class="skill-progress">
            <div class="skill-header">
              <span class="skill-name">Game Design</span>
              <span class="skill-level">90%</span>
            </div>
            <div class="progress-bar">
              <div class="progress-fill" style="width: 90%"></div>
            </div>
          </div>
          <div class="skill-progress">
            <div class="skill-header">
              <span class="skill-name">Level Design</span>
              <span class="skill-level">85%</span>
            </div>
            <div class="progress-bar">
              <div class="progress-fill" style="width: 85%"></div>
            </div>
          </div>
          <div class="skill-progress">
            <div class="skill-header">
              <span class="skill-name">UI/UX Design</span>
              <span class="skill-level">75%</span>
            </div>
            <div class="progress-bar">
              <div class="progress-fill" style="width: 75%"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="text-center">
        <h3 class="text-2xl font-bold mb-8">Additional Tools & Technologies</h3>
        <div class="tools-grid">
          <span class="tool-tag">Git</span>
          <span class="tool-tag">Perforce</span>
          <span class="tool-tag">Jira</span>
          <span class="tool-tag">Photoshop</span>
          <span class="tool-tag">After Effects</span>
          <span class="tool-tag">ZBrush</span>
          <span class="tool-tag">Houdini</span>
          <span class="tool-tag">Shader Graph</span>
          <span class="tool-tag">Blueprint</span>
          <span class="tool-tag">Motion Capture</span>
          <span class="tool-tag">Audio Design</span>
          <span class="tool-tag">Version Control</span>
        </div>
      </div>
    </div>
  </section>

  <!-- Contact Section -->
  <section id="contact" class="section">
    <div class="container">
      <div class="text-center mb-12">
        <h2 class="section-title">
          Get In <span class="primary relative">Touch</span>
        </h2>
      </div>

      <div class="contact-content">
        <div>
          <div class="mb-8">
            <h3 class="text-2xl font-bold mb-4">Let's Create Something Amazing</h3>
            <p class="text-lg" style="color: var(--muted-foreground);">
              Whether you have a project in mind or just want to chat about game development,
              I'd love to hear from you. Let's bring your vision to life!
            </p>
          </div>

          <div class="mb-8">
            <div class="contact-info">
              <div class="contact-icon">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
                  <polyline points="22,6 12,13 2,6"></polyline>
                </svg>
              </div>
              <div>
                <div class="font-semibold mb-1">Email</div>
                <a href="mailto:hello@gamedev.com" style="color: var(--muted-foreground); text-decoration: none;">
                  hello@gamedev.com
                </a>
              </div>
            </div>

            <div class="contact-info">
              <div class="contact-icon">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path
                    d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z">
                  </path>
                </svg>
              </div>
              <div>
                <div class="font-semibold mb-1">Phone</div>
                <a href="tel:+1234567890" style="color: var(--muted-foreground); text-decoration: none;">
                  +1 (234) 567-890
                </a>
              </div>
            </div>

            <div class="contact-info">
              <div class="contact-icon">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                  <circle cx="12" cy="10" r="3"></circle>
                </svg>
              </div>
              <div>
                <div class="font-semibold mb-1">Location</div>
                <div style="color: var(--muted-foreground);">Available for remote work worldwide</div>
              </div>
            </div>
          </div>

          <div class="mt-4">
            <p style="color: var(--muted-foreground); margin-bottom: 0.5rem;">Response time: Usually within 24 hours</p>
            <div class="status-indicator">
              <span class="status-dot"></span>
              Available for new projects
            </div>
          </div>
        </div>

        <div class="contact-form">
          <form onsubmit="handleFormSubmit(event)">
            <div class="form-group">
              <label for="name" class="form-label">Name</label>
              <input type="text" id="name" class="form-input" placeholder="Your name" required>
            </div>

            <div class="form-group">
              <label for="email" class="form-label">Email</label>
              <input type="email" id="email" class="form-input" placeholder="your.email@example.com" required>
            </div>

            <div class="form-group">
              <label for="message" class="form-label">Message</label>
              <textarea id="message" class="form-input form-textarea" placeholder="Tell me about your project..."
                required></textarea>
            </div>

            <button type="submit" class="btn-primary" style="width: 100%;">
              Send Message
            </button>
          </form>
        </div>
      </div>
    </div>
  </section>

  <script>
    // Projects data
    const projects = [
      // 3D Models
      {
        id: 1,
        title: "Door Console",
        description: "A futuristic, high-detail 3D door console designed for sci-fi environments and interactive scenes.",
        category: "3D Models",
        image: "DC1.png",
        tags: ["Blender", "Maya", "Sci-Fi"],
        fullDescription: "This futuristic door console features intricate mechanical details, illuminated panels, and modular components suitable for both cinematic and real-time applications. Built with precision and optimized topology, it’s ideal for use in sci-fi games, VR environments, or film set designs.",
        features: [
          "High-poly detailed modeling",
          "PBR materials with realistic surface detail",
          "Modular and customizable design",
          "Optimized for game engines (Unreal Engine, Unity)",
          "Includes multiple texture and color variants"
        ],
        images: [
          "DC1.png",
          "DC2.png",
          "DC3.png"
        ],
        code: [],
        liveDemo: "#",
        sourceCode: "#"
      },
      {
        id: 2,
        title: "Cooking Environment",
        description: "Complete 3D kitchen environment with detailed appliances and utensils.",
        category: "3D Models",
        image: "CE3.jpg",
        tags: ["Blender", "Maya", "Environment Design"],
        fullDescription: "I created a fully designed cooking environment inspired by the game Overcooked, featuring a detailed chef character, complete with kitchen tools, equipment, and a functional food truck. The project showcases a vibrant and dynamic setting that captures the fast-paced, chaotic energy of a professional kitchen. From the chef’s expressive design to the interactive cooking setup and food truck, every element was built to reflect creativity, teamwork, and culinary adventure.",
        features: [
          "Complete kitchen environment",
          "Realistic appliance models",
          "Detailed prop collection",
          "Optimized for real-time rendering",
          "Modular asset system"
        ],
        images: [
          "CE1.jpg",
          "CE2.jpg",
          "CE3.jpg",
          "E1.jpg",
          "E2.jpg",
          "E3.jpg"
        ],
        code: [
          {
            language: "Python",
            title: "Blender Automation Script",
            content: `import bpy
import bmesh

def create_character_base():
    # Clear existing mesh
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete(use_global=False)
    
    # Add base mesh
    bpy.ops.mesh.primitive_cube_add()
    obj = bpy.context.active_object
    
    # Enter edit mode and create base topology
    bpy.context.view_layer.objects.active = obj
    bpy.ops.object.mode_set(mode='EDIT')
    
    # Subdivide for detail
    bpy.ops.mesh.subdivide(number_cuts=3)
    
    # Apply subdivision surface modifier
    bpy.ops.object.mode_set(mode='OBJECT')
    modifier = obj.modifiers.new(name="SubSurf", type='SUBSURF')
    modifier.levels = 2
    
    return obj

def setup_materials():
    # Create PBR material
    mat = bpy.data.materials.new(name="CharacterMaterial")
    mat.use_nodes = True
    
    # Get material nodes
    nodes = mat.node_tree.nodes
    links = mat.node_tree.links
    
    # Clear default nodes
    nodes.clear()
    
    # Add Principled BSDF
    bsdf = nodes.new(type='ShaderNodeBsdfPrincipled')
    output = nodes.new(type='ShaderNodeOutputMaterial')
    
    # Link BSDF to output
    links.new(bsdf.outputs['BSDF'], output.inputs['Surface'])
    
    return mat

# Execute script
character = create_character_base()
material = setup_materials()
character.data.materials.append(material)`
          }
        ],
        liveDemo: "https://sketchfab.com/3d-models/sci-fi-character",
        sourceCode: "https://github.com/example/sci-fi-character"
      },
      {
        id: 4,
        title: "Card Matching Game",
        description: "A strategic memory puzzle game where players match cards and score points.",
        category: "Games",
        image: "MG3.jpg",
        tags: ["C#", "Visual Studio Code", "Memory Game"],
        fullDescription: "Card Match Challenge is an engaging 2D puzzle game that tests your memory and strategy skills. Flip cards to find pairs, uncover hidden patterns, and climb the leaderboard as the challenge intensifies. With colorful visuals and a simple yet addictive design, every move counts as you aim for the highest score.",
        contribution: "Solo project - Designed and developed the complete game mechanics, UI/UX implementation, scoring system, and card matching algorithms. Created responsive game logic and optimized performance for smooth gameplay experience.",
        features: [
          "Classic card-matching gameplay",
          "Dynamic scoring system",
          "Polished 2D visuals with smooth animations",
          "Progressively challenging levels",
          "Relaxing background music",
          "Built with Unity using C#"
        ],
        images: [
          "MG1.jpg",
          "MG2.jpg",
          "MG3.jpg",
          "MG4.jpg",
          "MG5.jpg"
        ],
        video: `<iframe src="https://drive.google.com/file/d/1dkgv5AIgh5xst3APH1VeCloFIrYqYScV/preview" allow="autoplay" allowfullscreen></iframe>`,
        code: [
          {
            language: "C#",
            title: "Form1.cs - Main Game Logic (Advanced Version)",
            content: `using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Media;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace CardMatchingGame
{
    public partial class Form1 : Form
    {
        private List<Image> cardImages = new List<Image>();
        private PictureBox firstClicked = null;
        private PictureBox secondClicked = null;
        private int score = 0;
        private Random random = new Random();
        private string imagePath = @"C:\\Users\\angel\\OneDrive - feutech.edu.ph\\Desktop\\PNG-cards-1.3";
        private SoundPlayer flipSound;
        private SoundPlayer winSound;

        public Form1()
        {
            InitializeComponent();
            LoadCardImages();
            AssignImagesToCards();
            SetPictureBoxSizeMode();
            LoadFlipSound();
            LoadWinSound();
        }

        private void LoadCardImages()
        {
            try
            {
                var imageFiles = Directory.GetFiles(imagePath, "*.png");
                foreach (var file in imageFiles.Take(18)) 
                {
                    var img = Image.FromFile(file);
                    cardImages.Add(img);
                    cardImages.Add(img); 
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error loading images: {ex.Message}");
            }
        }

        private void LoadFlipSound()
        {
            try
            {
                flipSound = new SoundPlayer(@"C:\\Users\\angel\\OneDrive - feutech.edu.ph\\Desktop\\Sounds\\Flipcard.wav");
                flipSound.Load();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error loading flip sound: {ex.Message}");
            }
        }

        private void LoadWinSound()
        {
            try
            {
                winSound = new SoundPlayer(@"C:\\Users\\angel\\OneDrive - feutech.edu.ph\\Desktop\\Sounds\\Win.wav");
                winSound.Load();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error loading win sound: {ex.Message}");
            }
        }

        private void AssignImagesToCards()
        {
            var shuffledImages = cardImages.OrderBy(x => random.Next()).ToList();

            int index = 0;
            foreach (Control control in tableLayoutPanel1.Controls)
            {
                if (control is PictureBox)
                {
                    var picBox = (PictureBox)control;
                    picBox.Tag = shuffledImages[index];
                    picBox.Click += new EventHandler(PictureBox_Click);
                    picBox.Image = null;
                    index++;
                }
            }
        }

        private void SetPictureBoxSizeMode()
        {
            foreach (Control control in tableLayoutPanel1.Controls)
            {
                if (control is PictureBox pictureBox)
                {
                    pictureBox.SizeMode = PictureBoxSizeMode.StretchImage;
                }
            }
        }

        private async void PictureBox_Click(object sender, EventArgs e)
        {
            if (firstClicked != null && secondClicked != null)
                return;

            var clickedBox = sender as PictureBox;
            if (clickedBox == null || clickedBox.Image != null)
                return;

            flipSound.Play(); 

            clickedBox.Image = (Image)clickedBox.Tag;

            if (firstClicked == null)
            {
                firstClicked = clickedBox;
                return;
            }

            secondClicked = clickedBox;

            if (firstClicked.Tag == secondClicked.Tag)
            {
                firstClicked = null;
                secondClicked = null;
                score += 5;
                scoreLabel.Text = $"Score: {score}";
                CheckForGameEnd();
                return;
            }

            await Task.Delay(800);

            firstClicked.Image = null;
            secondClicked.Image = null;

            firstClicked = null;
            secondClicked = null;
            if (score > 0) score--;
            scoreLabel.Text = $"Score: {score}";
        }

        private void CheckForGameEnd()
        {
            foreach (Control control in tableLayoutPanel1.Controls)
            {
                if (control is PictureBox picBox && picBox.Image == null)
                {
                    return;
                }
            }

            winSound.Play(); 
            MessageBox.Show($"Congratulations! Your final score is: {score}");
        }
    }`
          },
          {
            language: "C#",
            title: "MatchingGame.cs - Simple Version",
            content: `using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;

namespace MatchingGame
{
    public partial class Form1 : Form
    {
        Label firstClicked = null;
        Label secondClicked = null;
        Random random = new Random();
        int score = 0;

        // Initialize a list of 52 card values
        List<string> icons = new List<string>
        {
            "!", "!", "N", "N", ",", ",", "k", "k",
            "i", "i", "K", "K", "d", "d", "a", "a",
            "b", "b", "v", "v", "w", "w", "z", "z",
            "x", "x", "q", "q", "s", "s", "t", "t",
            "u", "u", "o", "o", "p", "p", "l", "l",
            "m", "m", "n", "n", "e", "e", "f", "f",
            "g", "g", "h", "h"
        };

        public Form1()
        {
            InitializeComponent();
            AssignIconsToSquares();
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            // Initialize the form and start the game
        }

        private void tableLayoutPanel1_Paint(object sender, PaintEventArgs e)
        {
            // Optional: Customize the table layout panel if needed
        }

        private void label1_Click(object sender, EventArgs e)
        {
            if (timer1.Enabled == true)
                return;

            Label clickedLabel = sender as Label;

            if (clickedLabel != null)
            {
                if (clickedLabel.ForeColor == Color.Black)
                    return;

                if (firstClicked == null)
                {
                    firstClicked = clickedLabel;
                    firstClicked.ForeColor = Color.Black;
                    return;
                }

                secondClicked = clickedLabel;
                secondClicked.ForeColor = Color.Black;

                CheckForWinner();

                if (firstClicked.Text == secondClicked.Text)
                {
                    score += 5;
                    firstClicked = null;
                    secondClicked = null;
                    return;
                }
                else
                {
                    if (score > 0)
                        score -= 1;
                    timer1.Start();
                }
            }
        }

        private void AssignIconsToSquares()
        {
            foreach (Control control in tableLayoutPanel1.Controls)
            {
                Label iconLabel = control as Label;
                if (iconLabel != null)
                {
                    int randomNumber = random.Next(icons.Count);
                    iconLabel.Text = icons[randomNumber];
                    iconLabel.ForeColor = iconLabel.BackColor;
                    icons.RemoveAt(randomNumber);
                }
            }
        }

        private void timer1_Tick(object sender, EventArgs e)
        {
            timer1.Stop();
            firstClicked.ForeColor = firstClicked.BackColor;
            secondClicked.ForeColor = secondClicked.BackColor;
            firstClicked = null;
            secondClicked = null;
        }

        private void CheckForWinner()
        {
            foreach (Control control in tableLayoutPanel1.Controls)
            {
                Label iconLabel = control as Label;

                if (iconLabel != null)
                {
                    if (iconLabel.ForeColor == iconLabel.BackColor)
                        return;
                }
            }

            MessageBox.Show($"You matched all the icons! Your score is {score}.", "Congratulations");
            Close();
        }
    }
}`
          },
          {
            language: "C#",
            title: "Form1.Designer.cs - UI Design",
            content: `namespace CardMatchingGame
{
    partial class Form1
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(Form1));
            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            
            // Initialize 36 PictureBox controls for the 6x6 grid
            this.pictureBox1 = new System.Windows.Forms.PictureBox();
            this.pictureBox2 = new System.Windows.Forms.PictureBox();
            // ... (continue for all 36 picture boxes)
            this.pictureBox36 = new System.Windows.Forms.PictureBox();
            
            this.scoreLabel = new System.Windows.Forms.Label();
            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();
            this.progressBar1 = new System.Windows.Forms.ProgressBar();
            
            this.tableLayoutPanel1.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();
            // ... (suspend layout for all picture boxes)
            this.tableLayoutPanel2.SuspendLayout();
            this.SuspendLayout();
            
            // 
            // tableLayoutPanel1
            // 
            this.tableLayoutPanel1.BackColor = System.Drawing.Color.SeaGreen;
            this.tableLayoutPanel1.ColumnCount = 6;
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 16.66667F));
            // ... (repeat for all 6 columns)
            
            this.tableLayoutPanel1.RowCount = 6;
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 16.66667F));
            // ... (repeat for all 6 rows)
            
            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Left;
            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);
            this.tableLayoutPanel1.Name = "tableLayoutPanel1";
            this.tableLayoutPanel1.Size = new System.Drawing.Size(748, 870);
            this.tableLayoutPanel1.TabIndex = 0;
            
            // Configure all picture boxes with background images and properties
            // ... (configuration for all 36 picture boxes)
            
            // 
            // scoreLabel
            // 
            this.scoreLabel.AutoSize = true;
            this.scoreLabel.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.scoreLabel.Location = new System.Drawing.Point(754, 0);
            this.scoreLabel.Name = "scoreLabel";
            this.scoreLabel.Size = new System.Drawing.Size(70, 20);
            this.scoreLabel.TabIndex = 1;
            this.scoreLabel.Text = "Score: 0";
            
            // Set up the form
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(1000, 870);
            this.Controls.Add(this.tableLayoutPanel2);
            this.Controls.Add(this.scoreLabel);
            this.Controls.Add(this.tableLayoutPanel1);
            this.Name = "Form1";
            this.Text = "Card Matching Game";
            this.Load += new System.EventHandler(this.Form1_Load);
            
            this.tableLayoutPanel1.ResumeLayout(false);
            // ... (resume layout for all picture boxes)
            this.tableLayoutPanel2.ResumeLayout(false);
            this.ResumeLayout(false);
            this.PerformLayout();
        }

        #endregion

        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;
        private System.Windows.Forms.PictureBox pictureBox1;
        // ... (declare all 36 picture boxes)
        private System.Windows.Forms.PictureBox pictureBox36;
        private System.Windows.Forms.Label scoreLabel;
        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel2;
        private System.Windows.Forms.ProgressBar progressBar1;
    }
}`
          },
          {
            language: "C#",
            title: "Program.cs - Application Entry Point",
            content: `using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace CardMatchingGame
{
    internal static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form1());
        }
    }
}`
          }
        ],
        liveDemo: "https://example.com/puzzle-game",
        sourceCode: "https://github.com/example/puzzle-platformer"
      },
      {
        id: 5,
        title: "Food Truck",
        description: "A stylized 3D food truck model designed for vibrant cityscapes, mobile games, and animated scenes.",
        category: "3D Models",
        image: "V1.jpg",
        tags: ["Blender", "Texturing", "Maya"],
        fullDescription: "This colorful and playful 3D food truck features a bold design with a giant burger sign, detailed serving area, and modular components for easy customization. Ideal for use in stylized environments, games, or animated shorts, this model combines simplicity and charm while maintaining a clean, optimized topology for performance.",
        features: [
          "Stylized, low-poly design suitable for animation and games",
          "Clean topology and optimized geometry",
          "PBR materials with bright, appealing colors",
          "Fully modeled interior details (burgers, condiments, and props)",
          "Ready for rendering and game engine integration (Unity, Unreal, Blender)"
        ],
        images: [
          "V1.jpg",
          "V2.jpg",
          "V3.jpg",
          "V4.jpg"
        ],
        code: [],
        liveDemo: "https://example.com/environment-showcase",
        sourceCode: "https://github.com/example/environment-assets"
      },
      {
        id: 7,
        title: "Chef Character",
        description: "A stylized 3D chef character designed for animation, games, and visual storytelling.",
        category: "3D Models",
        image: "CC1.jpg",
        tags: ["Blender", "Maya", "Character Modeling"],
        fullDescription: "This project features a stylized chef character model crafted in Blender, showcasing professional attire, expressive design, and attention to detail. The model is ideal for use in cooking-themed games, animations, or educational simulations. The character was designed with clean topology, balanced proportions, and a playful aesthetic to complement a variety of environments such as kitchen interiors and food trucks.",
        features: [
          "Stylized and appealing 3D character design",
          "Traditional chef uniform with detailed accessories",
          "Ready for facial rigging and animation",
          "Includes multiple environment renders (kitchen, dining area, food truck)",
          "Optimized for both real-time and rendered scenes"
        ],
        images: [
          "CC1.jpg",
          "CC2.jpg",
          "CC3.jpg"
        ],
        code: [],
        liveDemo: "#",
        sourceCode: "#"
      },
      {
        id: 8,
        title: "Weapon",
        description: "High-quality sci-fi weapon model with realistic materials, intricate detailing, and a game-ready design.",
        category: "3D Models",
        image: "Weapon1.jpg",
        tags: ["Substance Painter", "Weapon Design", "Maya"],
        fullDescription: "A highly detailed 3D weapon model designed with a futuristic aesthetic and optimized for real-time rendering. Created using Blender and Maya, it features realistic materials, subtle wear effects, and precise geometry ideal for both cinematic renders and game integration.",
        features: [
          "Futuristic weapon concept with intricate detailing",
          "Realistic PBR materials and texture workflow",
          "Visible wear, tear, and metallic surface effects",
          "Optimized topology for real-time performance",
          "Rig-ready structure for animation or game use"
        ],
        images: [
          "Weapon1.jpg",
          "Weapon2.jpg",
        ],
        code: [],
        liveDemo: "#",
        sourceCode: "#"
      },
      {
        id: 9,
        title: "Sci-Fi Control Room",
        description: "A detailed sci-fi control room environment featuring advanced holographic displays, futuristic workstations, and immersive lighting.",
        category: "3D Models",
        image: "PPreview.png",
        tags: ["Blender", "Maya", "Sci-Fi", "Environment Design"],
        fullDescription: "This futuristic control room scene is designed for high-tech environments, spaceship interiors, or sci-fi command centers. It features multiple interactive workstations, holographic display tables, and realistic lighting for cinematic or game-ready renders. With clean topology and modular components, it’s ideal for animation, games, and VR experiences.",
        features: [
          "High-quality sci-fi environment design",
          "Modular layout for flexible scene setup",
          "Emissive holographic displays and control panels",
          "Optimized geometry and PBR materials",
          "Suitable for cinematic, game, or VR applications"
        ],
        images: [
          "PPreview.png",
          "P1.jpg",
          "P2.png",
          "P3.jpg",
          "P4.jpg",
          "P5.jpg"
        ],
        code: [],
        liveDemo: "#",
        sourceCode: "#"
      },
      {
        id: 10,
        title: "Sci-Fi Wall",
        description: "A modular sci-fi wall with emissive details and realistic materials.",
        category: "3D Models",
        image: "W1.png",
        tags: ["Substance Painter", "Maya", "Sci-Fi"],
        fullDescription: "A detailed modular sci-fi wall designed for futuristic or industrial environments. Features emissive lighting, high-quality materials, and realistic wear and tear for immersive scene building.",
        features: [
          "Modular sci-fi wall sections",
          "Emissive and reflective materials",
          "High-resolution PBR textures",
          "Realistic wear and surface details",
          "Optimized for rendering and game engines"
        ],
        images: [
          "W1.png",
          "W2.jpg",
          "W3.jpg"
        ],
        code: [],
        liveDemo: "#",
        sourceCode: "#"
      },
      {
        id: 11,
        title: "Chess Piece",
        description: "Elegant chess piece set with detailed craftsmanship and materials.",
        category: "3D Models",
        image: "Chess1.jpg",
        tags: ["Blender", "Product Design", "Maya"],
        fullDescription: "A beautifully crafted chess scene featuring classic piece designs rendered with modern materials, realistic lighting, and fine attention to detail. The composition captures the elegance and atmosphere of a cozy chess setup, showcasing both artistry and technical precision.",
        features: [
          "Realistic chessboard and piece designs with smooth materials",
          "Warm lighting setup for a cozy, natural atmosphere",
          "Detailed table and props including a cup, lamp, and timer",
          "Physically accurate rendering with reflections and shadows",
          "Balanced scene composition showcasing modeling and texturing skills"
        ],
        images: [
          "Chess1.jpg",
          "Chess2.jpg",
          "Chess3.jpg"
        ],
        code: [],
        liveDemo: "#",
        sourceCode: "#"
      },
      {
        id: 12,
        title: "Helicopter Island Scene",
        description: "Low-poly island environment featuring a helicopter, windmill, and tropical setting.",
        category: "Animations",
        image: "H1.jpg",
        tags: ["Maya", "Animation", "Low-Poly", "Environment"],
        fullDescription: "A stylized low-poly island environment showcasing a helicopter landing zone, tropical palm trees, wooden structures, and a scenic coastal view. Perfect for animation projects, games, or environment showcases.",
        features: [
          "Low-poly helicopter and island assets",
          "Stylized tropical environment",
          "Custom lighting and water shaders",
          "Optimized for animation and rendering",
          "Includes windmill, trees, and house props"
        ],
        images: [
          "H1.jpg",
          "H2.jpg",
          "H3.jpg",
          "H4.jpg",
          "H5.jpg",
          "H6.jpg",
          "H7.jpg",
          "H8.jpg"
        ],
        video: '<iframe src="https://drive.google.com/file/d/11Xq7OI4QvxzBae7jdit0i8cF5HEtGVX8/preview" width="100%" height="400" allow="autoplay" allowfullscreen></iframe>',
        code: [],
        liveDemo: "#",
        sourceCode: "#"
      },
      {
        id: 13,
        title: "Billiards Room",
        description: "Realistic billiards setup with physics-based interactions and detailed wooden interiors.",
        category: "Animations",
        image: "B1.jpg",
        tags: ["Maya", "Physics Animation", "Environment", "Low-Poly"],
        fullDescription: "A detailed billiards room scene featuring a realistic pool table, dynamic lighting, and physics-based ball interactions. Includes wooden flooring, benches, and props like basketballs and decorative objects for added realism.",
        features: [
          "Physics-based billiard ball simulation",
          "Realistic lighting and materials",
          "Detailed wooden interior design",
          "Dynamic camera and object interaction setup",
          "Optimized for rendering and animation"
        ],
        images: [
          "B1.jpg",
          "B2.jpg",
          "B3.jpg",
          "B4.jpg",
          "B5.jpg",
          "B6.jpg",
          "B7.jpg",
          "B8.jpg"

        ],
        video: '<iframe src="https://drive.google.com/file/d/1bLBMr42LabfQ65ekSJRjsQ6UgGTFkGO4/preview" width="100%" height="400" allow="autoplay" allowfullscreen></iframe>',
        code: [],
        liveDemo: "#",
        sourceCode: "#"
      },
      {
        id: 14,
        title: "Set Drive Helicopter",
        description: "Low-poly city scene featuring a helicopter animation using set-driven keys.",
        category: "Animations",
        image: "SD3.jpg",
        tags: ["Maya", "Set Driven Keys", "Low-Poly", "Animation"],
        fullDescription: "A low-poly city environment showcasing a helicopter animation controlled through set-driven keys. Features animated rotors, landing sequences, and detailed urban surroundings, ideal for animation or simulation projects.",
        features: [
          "Helicopter animation with set-driven keys",
          "Low-poly city environment",
          "Animated rotor and landing system",
          "Custom lighting and materials",
          "Optimized for rendering and real-time use"
        ],
        images: [
          "SD1.jpg",
          "SD2.jpg",
          "SD3.jpg",
          "SD4.jpg",
          "SD5.jpg",
          "SD6.jpg"
        ],
        video: '<iframe src="https://drive.google.com/file/d/1uW7RSII1dEifzidpouniQ9AzJdEizruT/preview" width="100%" height="400" allow="autoplay" allowfullscreen></iframe>',
        code: [],
        liveDemo: "#",
        sourceCode: "#"
      },
      {
        id: 19,
        title: "Minatamis",
        description: "A culturally inspired PC simulation game where players prepare and sell traditional Filipino desserts.",
        category: "Games",
        image: "M2.png",
        tags: ["Unity", "Simulation", "PC Game", "Filipino Culture"],
        fullDescription: "MinaTamis is a Filipino-themed PC simulation game where players become local dessert vendors preparing and selling classic treats like hotcakes. Blending fun gameplay with cultural learning, it celebrates Filipino culinary heritage through interactive storytelling and immersive mechanics inspired by Cooking Simulator and Cooking Mama.",
        contribution: "Lead Developer - Responsible for game design, Unity implementation, cultural research, and educational content integration. Developed simulation mechanics, customer interaction systems, and authentic Filipino dessert preparation workflows.",
        features: [
          "Interactive Filipino dessert preparation and selling system",
          "Vibrant and authentic local environment",
          "Culturally inspired characters and design",
          "Educational gameplay promoting Filipino heritage",
          "Unlockable content and store customization options",
          "Optimized for PC with intuitive controls"
        ],
        images: [
          "M1.png",
          "M2.png",
          "M3.png",
          "M4.png",
          "M5.png",
          "M6.png",
          "M7.png",
          "M8.png",
          "M9.png"
        ],
        video: `<iframe src="https://drive.google.com/file/d/16shUrsRO9GCC2So1PiTnQIcWvtAeX_ZX/preview" allow="autoplay" allowfullscreen></iframe>`,
        code: [],
        liveDemo: "#",
        sourceCode: "#"
      },
      {
        id: 20,
        title: "Tusok Tusok",
        description: "Traditional Filipino game digitally recreated with modern gameplay elements.",
        category: "Games",
        image: "https://images.unsplash.com/photo-1556909114-54fb2617e5ce?w=800&q=80",
        tags: ["Unity", "Cultural Game"],
        fullDescription: "A digital recreation of the traditional Filipino game 'Tusok Tusok' featuring modern gameplay mechanics while preserving cultural authenticity.",
        contribution: "Solo Developer - Researched traditional Filipino gaming culture, designed digital adaptation mechanics, implemented multiplayer functionality, and created educational content to preserve cultural heritage through modern gaming technology.",
        features: [
          "Traditional Filipino gameplay",
          "Cultural authenticity",
          "Modern UI/UX design",
          "Multiplayer support",
          "Educational elements"
        ],
        images: [
          "https://images.unsplash.com/photo-1556909114-54fb2617e5ce?w=800&q=80"
        ],
        code: [],
        liveDemo: "#",
        sourceCode: "#"
      },
      {
        id: 15,
        title: "Agent Snow",
        description: "A tactical stealth-action shooter set in a high-tech facility, combining strategy, precision, and immersive level design.",
        category: "Games",
        image: "AS11.jpg",
        tags: ["Unity", "Stealth Action"],
        fullDescription: "Agent Snow is a stealth-action shooter where players take control of a skilled operative on covert missions within high-security environments. The game emphasizes strategic movement, tactical decision-making, and precision shooting. Navigate through futuristic corridors, outsmart enemy patrols, and complete objectives with limited resources and time pressure.",
        contribution: "Game Designer & Developer - Created stealth mechanics, designed AI patrol systems, implemented tactical shooting mechanics, developed level architecture, and optimized performance for smooth gameplay across different hardware configurations.",
        features: [
          "Stealth-focused gameplay with tactical shooting elements",
          "Immersive sci-fi environments and detailed level design",
          "Dynamic enemy AI with varied patrol behaviors",
          "Multiple paths and strategies for each mission",
          "Resource management and time-based challenges"
        ],
        images: [
          "AS1.jpg",
          "AS2.jpg",
          "AS3.jpg",
          "AS4.jpg",
          "AS5.jpg",
          "AS6.jpg",
          "AS7.jpg",
          "AS8.jpg",
          "AS9.jpg",
          "AS10.jpg",
          "AS11.jpg",
          "AS12.jpg",
          "AS13.jpg",
        ],
        video: `<iframe src="https://drive.google.com/file/d/1x09YcBf93kI7i_ClkoJMKIxbcUKMwRzt/preview" allow="autoplay" allowfullscreen></iframe>`,
        code: [
          {
            language: "C#",
            title: "PlayerMotor.cs - Player Movement System",
            content: `using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerMotor : MonoBehaviour
{
    private CharacterController controller;
    private Vector3 playerVelocity;
    public float speed = 3f;
    private bool isGrounded;
    public float gravity = -9.8f;
    public float jumpHeight = .1f;

    private bool crouching = false;
    private bool lerpCrouch = false;
    private float crouchTimer = 0f;
    private bool sprinting = false;

    private PlayerHealth playerHealth;

    void Start()
    {
        controller = GetComponent<CharacterController>();
        playerHealth = GetComponent<PlayerHealth>();
    }

    void Update()
    {
        isGrounded = controller.isGrounded;
        if (lerpCrouch)
        {
            crouchTimer += Time.deltaTime;
            float p = crouchTimer / 1;
            p *= p;
            if (crouching)
                controller.height = Mathf.Lerp(controller.height, 1, p);
            else
                controller.height = Mathf.Lerp(controller.height, 2, p);

            if (p > 1)
            {
                lerpCrouch = false;
                crouchTimer = 0f;
            }
        }
    }

    public void JumpButton()
    {
        Jump();
    }

    public void CrouchButton()
    {
        Crouch();
    }

    public void SprintButton()
    {
        Sprint();
    }

    public void Jump()
    {
        if (isGrounded)
        {
            playerVelocity.y = Mathf.Sqrt(jumpHeight * -3.0f * gravity);
        }
    }

    public void Crouch()
    {
        crouching = !crouching;
        crouchTimer = 0;
        lerpCrouch = true;
    }

    public void Sprint()
    {
        if (playerHealth != null && playerHealth.isFrozen)
        {
            sprinting = false;
            speed = 2.5f;
            return;
        }

        sprinting = !sprinting;
        speed = sprinting ? 5 : 3;
    }

    public void ProcessMove(Vector3 input)
    {
        Vector3 moveDirection = Vector3.zero;
        moveDirection.x = input.x;
        moveDirection.y = input.y;
        moveDirection.z = input.z;
        controller.Move(transform.TransformDirection(moveDirection) * speed * Time.deltaTime);
        playerVelocity.y += gravity * Time.deltaTime;
        if (isGrounded && playerVelocity.y < 0)
            playerVelocity.y = -2f;
        controller.Move(playerVelocity * speed * Time.deltaTime);
    }
}`
          },
          {
            language: "C#",
            title: "UnifiedEnemyAI.cs - Enemy AI System",
            content: `using UnityEngine;
using UnityEngine.AI;

public class UnifiedEnemyAI : MonoBehaviour
{
    [Header("Health Settings")]
    public int maxHealth = 100;
    private int currentHealth;

    [Header("Patrolling Settings")]
    public Transform[] patrolPoints;
    private int currentPatrolIndex;

    [Header("Chasing and Detection")]
    public float chaseRange = 10f;
    public float sightRange = 15f;
    public float fieldOfView = 60f;
    public Transform player;
    [SerializeField()]
    private bool isChasing;

    [Header("Shooting Settings")]
    public GameObject bulletPrefab;
    public Transform firePoint;
    public float bulletSpeed = 15f;
    public float fireRate = 1f;
    [SerializeField()]
    private float nextFireTime;

    [Header("Movement Settings")]
    public float moveSpeed = 3.5f; // Movement speed
    public float turnSpeed = 5f; // Turning speed

    private NavMeshAgent agent;

    private void Start()
    {
        agent = GetComponent<NavMeshAgent>();
        currentHealth = maxHealth;
        currentPatrolIndex = 0;
        agent.speed = moveSpeed; // Set the movement speed
        agent.angularSpeed = turnSpeed * 100; // Convert turn speed to angular speed (degrees per second)
        MoveToNextPatrolPoint();
    }

    private void Update()
    {
        if (PlayerInSight())
        {
            isChasing = true;
            ChasePlayer();
        }
        else if (isChasing)
        {
            isChasing = false;
            MoveToNextPatrolPoint();
        }

        if (!isChasing && !agent.pathPending && agent.remainingDistance < 0.5f)
        {
            MoveToNextPatrolPoint();
        }

        if (Time.time >= nextFireTime && isChasing && Vector3.Distance(transform.position, player.position) <= chaseRange)
        {
            Shoot();
            nextFireTime = Time.time + fireRate;
        }
    }

    private void MoveToNextPatrolPoint()
    {
        if (patrolPoints.Length == 0)
            return;

        agent.destination = patrolPoints[currentPatrolIndex].position;
        currentPatrolIndex = (currentPatrolIndex + 1) % patrolPoints.Length;
    }

    private void ChasePlayer()
    {
        agent.SetDestination(player.position);
    }

    private bool PlayerInSight()
    {
        Vector3 directionToPlayer = (player.position - transform.position).normalized;
        float angleToPlayer = Vector3.Angle(transform.forward, directionToPlayer);

        if (angleToPlayer < fieldOfView / 2f && Vector3.Distance(transform.position, player.position) <= sightRange)
        {
            Ray ray = new Ray(transform.position, directionToPlayer);
            if (Physics.Raycast(ray, out RaycastHit hit, sightRange))
            {
                if (hit.collider.CompareTag("Player"))
                {
                    return true;
                }
            }
        }

        return false;
    }

    private void Shoot()
    {
        GameObject bullet = Instantiate(bulletPrefab, firePoint.position, firePoint.rotation);
        Rigidbody rb = bullet.GetComponent<Rigidbody>();
        if (rb != null)
        {
            Vector3 directionToPlayer = (player.position - firePoint.position).normalized;
            rb.linearVelocity = directionToPlayer * bulletSpeed;
        }
    }

    public void TakeDamage(int damage)
    {
        currentHealth -= damage; // Reduce health by the given damage
        Debug.Log($"Enemy Health: {currentHealth}");

        if (currentHealth <= 0)
        {
            Die();
        }
    }

    private void Die()
    {
        Debug.Log("Enemy Died!");

        // Add 100 points to the score
        if (ScoreManager.Instance != null)
        {
            ScoreManager.Instance.AddScore(100);
        }

        Destroy(gameObject); // Remove the enemy from the scene
    }
}`
          },
          {
            language: "C#",
            title: "Gun.cs - Weapon System",
            content: `using System.Collections;
using UnityEngine;
using TMPro;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class Gun : MonoBehaviour
{
    [Header("Gun Settings")]
    public GameObject bulletPrefab;
    public Transform firePoint;
    public float bulletSpeed = 50f;
    public float fireRate = 0.2f;
    private float nextFireTime = 0f;

    [Header("Ammo Settings")]
    public int maxAmmo = 20;
    public int currentAmmo;
    public float reloadTime = 2f;
    private bool isReloading = false;

    [Header("UI Settings")]
    public TextMeshProUGUI ammoText;
    public TextMeshProUGUI reloadingText;
    public Button fireButton;
    public Button reloadButton;

    private bool isFiring = false;

    void Start()
    {
        currentAmmo = maxAmmo;
        reloadingText.gameObject.SetActive(false);

        if (fireButton != null)
        {
            EventTrigger trigger = fireButton.gameObject.AddComponent<EventTrigger>();

            EventTrigger.Entry pointerDown = new EventTrigger.Entry { eventID = EventTriggerType.PointerDown };
            pointerDown.callback.AddListener((data) => { isFiring = true; });
            trigger.triggers.Add(pointerDown);

            EventTrigger.Entry pointerUp = new EventTrigger.Entry { eventID = EventTriggerType.PointerUp };
            pointerUp.callback.AddListener((data) => { isFiring = false; });
            trigger.triggers.Add(pointerUp);
        }
        else
        {
            Debug.LogError("Fire button is not assigned in the Inspector!");
        }

        if (reloadButton != null)
        {
            reloadButton.onClick.AddListener(ReloadButtonClicked);
        }
        else
        {
            Debug.LogError("Reload button is not assigned in the Inspector!");
        }
    }

    void Update()
    {
        if (isReloading) return;

        if (currentAmmo <= 0)
        {
            StartCoroutine(Reload());
            return;
        }

        if (Input.GetKeyDown(KeyCode.R))
        {
            StartCoroutine(Reload());
        }

        if (isFiring && Time.time >= nextFireTime)
        {
            nextFireTime = Time.time + fireRate;
            Shoot();
        }

        UpdateAmmoUI();
    }

    public void ReloadButtonClicked()
    {
        if (!isReloading && currentAmmo < maxAmmo)
        {
            StartCoroutine(Reload());
        }
    }

    void Shoot()
    {
        currentAmmo--;
        GameObject bullet = Instantiate(bulletPrefab, firePoint.position, firePoint.rotation);
        Rigidbody rb = bullet.GetComponent<Rigidbody>();
        if (rb != null)
        {
            rb.linearVelocity = firePoint.forward * bulletSpeed;
        }
        else
        {
            Debug.LogError("Bullet prefab is missing a Rigidbody component!");
        }
    }

    IEnumerator Reload()
    {
        if (currentAmmo == maxAmmo) yield break;

        isReloading = true;
        reloadingText.gameObject.SetActive(true);
        yield return new WaitForSeconds(reloadTime);
        currentAmmo = maxAmmo;
        isReloading = false;
        reloadingText.gameObject.SetActive(false);
    }

    void UpdateAmmoUI()
    {
        if (ammoText != null)
        {
            ammoText.text = $"Ammo: {currentAmmo}/{maxAmmo}";
        }
    }
}`
          },
          {
            language: "C#",
            title: "PlayerHealth.cs - Health Management",
            content: `using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

public class PlayerHealth : MonoBehaviour
{
    private float health;
    private float lerpTimer;

    [Header("Health Bar")]
    public float maxHealth = 100f;
    public float chipSpeed = 2f;
    public Image frontHealthBar;
    public Image backHealthBar;

    [Header("Damage Overlay")]
    public Image overlay;
    public float duration;
    public float fadeSpeed;

    [Header("Freeze Effect")]
    public Image freezeOverlay;
    public float freezeDuration = 5f;
    public float slowedSpeed = 2f;
    private float originalSpeed;
    public bool isFrozen = false;

    [Header("Poison Effect")]
    public Image poisonOverlay;
    public float poisonRate = 1f;
    public float poisonThreshold = 20f;
    private bool isPoisoned = false;

    private float durationTimer;
    public PlayerMotor playerMotor;
    private CameraShake cameraShake;

    void Start()
    {
        health = maxHealth;
        overlay.color = new Color(overlay.color.r, overlay.color.g, overlay.color.b, 0);

        cameraShake = Camera.main.GetComponent<CameraShake>();

        if (freezeOverlay != null)
            freezeOverlay.color = new Color(freezeOverlay.color.r, freezeOverlay.color.g, freezeOverlay.color.b, 0);
        if (poisonOverlay != null)
            poisonOverlay.color = new Color(poisonOverlay.color.r, poisonOverlay.color.g, poisonOverlay.color.b, 0);

        originalSpeed = slowedSpeed;
    }

    void Update()
    {
        health = Mathf.Clamp(health, 0, maxHealth);
        UpdateHealthUI();

        // player die
        if (health <= 0)
        {
            Cursor.lockState = CursorLockMode.None;
            Cursor.visible = true;
            SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex + 2);
        }

        // Handle damage overlay fade
        if (health < 100 || isPoisoned)
        {
            if (overlay.color.a < 1)
            {
                overlay.color = new Color(overlay.color.r, overlay.color.g, overlay.color.b, 1f);
            }
        }
        else
        {
            if (overlay.color.a > 0)
            {
                durationTimer += Time.deltaTime;
                if (durationTimer > duration)
                {
                    float tempAlpha = overlay.color.a;
                    tempAlpha -= Time.deltaTime * fadeSpeed;
                    overlay.color = new Color(overlay.color.r, overlay.color.g, overlay.color.b, tempAlpha);
                }
            }
        }

        // Handle poison effect
        if (isPoisoned && health > poisonThreshold)
        {
            health -= poisonRate * Time.deltaTime;
        }
    }

    public void TakeDamage(float damage)
    {
        health -= damage;
        lerpTimer = 0f;
        durationTimer = 0;
        overlay.color = new Color(overlay.color.r, overlay.color.g, overlay.color.b, 1);

        // Deduct 1 point from the score
        if (ScoreManager.Instance != null)
        {
            ScoreManager.Instance.AddScore(-1);
        }

        // Trigger camera shake on damage
        if (cameraShake != null)
        {
            cameraShake.Shake();
        }

        UpdateHealthUI();
    }

    public void UpdateHealthUI()
    {
        float fillF = frontHealthBar.fillAmount;
        float fillB = backHealthBar.fillAmount;
        float hFraction = health / maxHealth;

        if (fillB > hFraction)
        {
            frontHealthBar.fillAmount = hFraction;
            backHealthBar.color = Color.red;
            lerpTimer += Time.deltaTime;
            float percentComplete = lerpTimer / chipSpeed;
            percentComplete = percentComplete * percentComplete;
            backHealthBar.fillAmount = Mathf.Lerp(fillB, hFraction, percentComplete);
        }

        if (fillF < hFraction)
        {
            backHealthBar.color = Color.green;
            backHealthBar.fillAmount = hFraction;
            lerpTimer += Time.deltaTime;
            float percentComplete = lerpTimer / chipSpeed;
            percentComplete = percentComplete * percentComplete;
            frontHealthBar.fillAmount = Mathf.Lerp(fillF, backHealthBar.fillAmount, percentComplete);
        }
    }

    public void RestoreHealth(float healAmount)
    {
        health += healAmount;
        lerpTimer = 0f;
    }
}`
          },
          {
            language: "C#",
            title: "InputManager.cs - Input Handling",
            content: `using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;

public class InputManager : MonoBehaviour
{
    private PlayerInput playerInput;
    public PlayerInput.OnFootActions onFoot;
    private PlayerMotor motor;
    private PlayerLook look;

    [SerializeField] private VirtualJoystick joystick; // Reference to the Virtual Joystick

    private void Start()
    {
        // Lock the cursor to the center
        Cursor.lockState = CursorLockMode.Locked;
    }

    void Awake()
    {
        playerInput = new PlayerInput();
        onFoot = playerInput.OnFoot;

        motor = GetComponent<PlayerMotor>();
        look = GetComponent<PlayerLook>();

        // Bind inputs
        onFoot.Jump.performed += ctx => motor.Jump();
        onFoot.Crouch.performed += ctx => motor.Crouch();
        onFoot.Sprint.performed += ctx => motor.Sprint();
    }

    void FixedUpdate()
    {
        Vector3 moveInput;

        if (joystick != null)
        {
            Vector2 joystickInput = joystick.Handle.anchoredPosition.normalized; // Use exposed Handle property
            moveInput = new Vector3(joystickInput.x, 0, joystickInput.y);
        }
        else
        {
            moveInput = onFoot.Movement.ReadValue<Vector3>(); // Use keyboard/controller input
        }

        motor.ProcessMove(moveInput);
    }

    private void LateUpdate()
    {
        look.ProcessLook(onFoot.Look.ReadValue<Vector2>());
    }

    private void OnEnable()
    {
        onFoot.Enable();
    }

    private void OnDisable()
    {
        onFoot.Disable();
    }
}`
          },
          {
            language: "C#",
            title: "Bullet.cs - Projectile System",
            content: `using UnityEngine;

public class Bullet : MonoBehaviour
{
    public int damage = 20;
    public float lifeTime = 2f;

    void Start()
    {
        Destroy(gameObject, lifeTime);
    }

    private void OnCollisionEnter(Collision collision)
    {
        UnifiedEnemyAI enemy = collision.collider.GetComponent<UnifiedEnemyAI>();
        if (enemy != null)
        {
            enemy.TakeDamage(damage);
        }

        SlimeBossAI boss = collision.collider.GetComponent<SlimeBossAI>();
        if (boss != null)
        {
            boss.TakeDamage(damage);
        }

        Destroy(gameObject);
    }
}`
          },
          {
            language: "C#",
            title: "EnemyBullet.cs - Enemy Projectiles",
            content: `using UnityEngine;

public class EnemyBullet : MonoBehaviour
{
    public int damage = 20; // Bullet damage
    public float lifeTime = 2f;

    void Start()
    {
        Destroy(gameObject, lifeTime); // Destroy bullet after some time
    }

    private void OnCollisionEnter(Collision collision)
    {
        // Check if the collided object is the player
        PlayerHealth playerHealth = collision.collider.GetComponent<PlayerHealth>();
        if (playerHealth != null)
        {
            playerHealth.TakeDamage(damage); // Deal damage to the player
        }

        Destroy(gameObject); // Destroy the bullet on impact
    }
}`
          },
          {
            language: "C#",
            title: "CameraShake.cs - Screen Effects",
            content: `using System.Collections;
using UnityEngine;

public class CameraShake : MonoBehaviour
{
    private Vector3 originalPosition;
    public float shakeDuration = 0.5f;
    public float shakeMagnitude = 0.1f;
    private float shakeTimeRemaining;

    void Start()
    {
        originalPosition = transform.localPosition;
    }

    public void Shake()
    {
        shakeTimeRemaining = shakeDuration;
        StartCoroutine(ShakeCoroutine());
    }

    private IEnumerator ShakeCoroutine()
    {
        while (shakeTimeRemaining > 0)
        {
            float x = Random.Range(-shakeMagnitude, shakeMagnitude);
            float y = Random.Range(-shakeMagnitude, shakeMagnitude);

            // Apply the shake within a limited range around the original position
            transform.localPosition = originalPosition + new Vector3(x, y, 0);

            shakeTimeRemaining -= Time.deltaTime;
            yield return null;
        }

        // Restore the original position after shaking
        transform.localPosition = originalPosition;
    }
}`
          },
          {
            language: "C#",
            title: "GameTimer.cs - Game Management",
            content: `using TMPro;
using UnityEngine;

public class GameTimer : MonoBehaviour
{
    public TextMeshProUGUI timerText; // Assign a UI Text element to display the timer.
    private float elapsedTime = 0f;   // Tracks the elapsed time.
    private bool isPaused = false;    // Tracks whether the timer is paused.

    void Update()
    {
        if (!isPaused && Time.timeScale > 0)
        {
            elapsedTime += Time.deltaTime;
            UpdateTimerDisplay();
        }
    }

    public void PauseTimer()
    {
        isPaused = true;
    }

    public void ResumeTimer()
    {
        isPaused = false;
    }

    private void UpdateTimerDisplay()
    {
        int minutes = Mathf.FloorToInt(elapsedTime / 60f);
        int seconds = Mathf.FloorToInt(elapsedTime % 60f);
        timerText.text = string.Format("{0:00}:{1:00}", minutes, seconds);
    }

    public void SaveElapsedTime()
    {
        GameData.TotalTime = elapsedTime; // Save the total elapsed time
    }
}`
          },
          {
            language: "C#",
            title: "GameData.cs - Data Management",
            content: `using UnityEngine;

public static class GameData
{
    public static float TotalTime = 0f; // Store total elapsed time
    public static int TotalScore = 0;   // Store total score
}`
          },
          {
            language: "C#",
            title: "Interactable.cs - Interaction System",
            content: `using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public abstract class Interactable : MonoBehaviour
{
    // add or remove events to gameobject
    public bool useEvents;
    // display message when near interactable
    [SerializeField]
    public string promptMessage;

    // called from player
    public void BaseInteract()
    {
        if (useEvents)
            GetComponent<InteractionEvents>().OnInteract.Invoke();
        Interact();
    }

    protected virtual void Interact()
    {
       
    }
}`
          }
        ],
        liveDemo: "#",
        sourceCode: "#"
      },
      {
        id: 16,
        title: "Pixel Z",
        description: "A retro-inspired 2D platformer combining classic gameplay with modern polish and fluid mechanics.",
        category: "Games",
        image: "PZ14.jpg",
        tags: ["Unity", "2D Platformer"],
        fullDescription: "Pixel Z is a modern take on the classic 2D platformer, blending nostalgic pixel art with smooth movement, responsive combat, and thoughtfully crafted levels. Players traverse a post-apocalyptic world filled with hazards, enemies, and collectibles, mastering precise controls and timing to progress through increasingly challenging stages.",
        contribution: "Lead Developer - Designed player movement systems, created pixel art assets, implemented combat mechanics, designed level architecture, and developed progression systems. Focused on creating responsive controls and satisfying gameplay loops.",
        features: [
           "Tight and responsive platforming controls",
           "Dynamic combat and collectible-driven progression",
           "Stylized pixel art visuals with atmospheric environments",
           "Modern level design inspired by classic platformers",
           "Gradually increasing difficulty that rewards skill and exploration"
        ],
        images: [
          "PZ1.jpg",
          "PZ2.jpg",
          "PZ3.jpg",
          "PZ4.jpg",
          "PZ5.jpg",
          "PZ6.jpg",
          "PZ7.jpg",
          "PZ8.jpg",
          "PZ9.jpg",
          "PZ10.jpg",
          "PZ11.jpg",
          "PZ12.jpg",
          "PZ13.jpg",
          "PZ14.jpg"
        ],
        video: '<iframe src="https://drive.google.com/file/d/1EyNT7vtar1VHJm5wV0ESRMCBf1kkAvFp/preview" width="100%" height="400" allow="autoplay" allowfullscreen></iframe>',
        code: [
          {
            language: "C#",
            title: "PlayerMovement.cs - Player Controller",
            content: `using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;

public class PlayerMovement : MonoBehaviour
{
    public Rigidbody2D rb;
    public Animator animator;
    bool isFacingRight = true;
    public ParticleSystem smokeFX;

    [Header("Movement")]
    public float moveSpeed = 5f;
    float horizontalMovement;

    [Header("Jumping")]
    public float jumpPower = 10f;
    public int maxJumps = 2;
    int jumpsRemaining;

    [Header("GroundCheck")]
    public Transform groundCheckPos;
    public Vector2 groundCheckSize = new Vector2(0.5f, 0.5f);
    public LayerMask groundLayer;
    bool isGrounded;

    [Header("Gravity")]
    public float baseGravity = 2f;
    public float maxFallSpeed = 18f;
    public float fallSpeedMultiplier = 2f;

    [Header("WallCheck")]
    public Transform wallCheckPos;
    public Vector2 wallCheckSize = new Vector2(0.5f, 0.5f);
    public LayerMask wallLayer;

    [Header("WallMovement")]
    public float wallSlideSpeed = 2f;
    bool isWallSliding;

    //Wall Jumping
    bool isWallJumping;
    float wallJumpDirection;
    float wallJumpTime = 0.5f;
    float wallJumpTimer;
    public Vector2 wallJumpPower = new Vector2(5f, 10f);

    void Update()
    {
        GroundCheck();
        ProcessGravity();
        ProcessWallSlide();
        ProcessWallJump(); 

        if(!isWallJumping)
        {
            rb.linearVelocity = new Vector2(horizontalMovement * moveSpeed, rb.linearVelocity.y);
            flip();
        }
        animator.SetFloat("yVelocity", rb.linearVelocity.y);
        animator.SetFloat("magnitude", rb.linearVelocity.magnitude);
        animator.SetBool("isWallSliding", isWallSliding);
    }

    public void Move(InputAction.CallbackContext context)
    {
        horizontalMovement = context.ReadValue<Vector2>().x;
    }

    public void Jump(InputAction.CallbackContext context)
    {
        if (jumpsRemaining > 0)
        {
            if (context.performed)
            {
                rb.linearVelocity = new Vector2(rb.linearVelocity.x, jumpPower);
                jumpsRemaining--;
                JumpFX();
            }
            else if (context.canceled)
            {
                rb.linearVelocity = new Vector2(rb.linearVelocity.x, rb.linearVelocity.y * 0.5f);
                jumpsRemaining--;
                JumpFX();
            }
        }

        //Wall Jump
        if (context.performed && wallJumpTimer > 0f)
        {
            isWallJumping = true;
            rb.linearVelocity = new Vector2(wallJumpDirection * wallJumpPower.x, wallJumpPower.y);
            wallJumpTimer = 0f;
            JumpFX();

            //Force flip
            if (transform.localScale.x != wallJumpDirection)
            {
                isFacingRight = !isFacingRight;
                Vector3 ls = transform.localScale;
                ls.x *= -1f;
                transform.localScale = ls;
            }

            Invoke(nameof(CancelWallJump), wallJumpTime + 0.1f);
        }
    }

    private void JumpFX()
    {
        animator.SetTrigger("jump");
        smokeFX.Play();
    }

    private void GroundCheck()
    { 
        if (Physics2D.OverlapBox(groundCheckPos.position, groundCheckSize, 0, groundLayer))
        {
            jumpsRemaining = maxJumps;
            isGrounded = true;
        }
        else
        {
            isGrounded = false;
        }
    }

    private bool WallCheck()
    {
        return Physics2D.OverlapBox(wallCheckPos.position, wallCheckSize, 0, wallLayer);
    }

    private void ProcessGravity()
    {
        if (rb.linearVelocity.y < 0)
        {
            rb.gravityScale = baseGravity * fallSpeedMultiplier;
            rb.linearVelocity = new Vector2(rb.linearVelocity.x, Mathf.Max(rb.linearVelocity.y - maxFallSpeed));
        }
        else
        {
            rb.gravityScale = baseGravity;
        }
    }

    private void ProcessWallSlide()
    {
        if (!isGrounded & WallCheck() & horizontalMovement != 0)
        {
            isWallSliding = true;
            rb.linearVelocity = new Vector2(rb.linearVelocity.x, Mathf.Max(rb.linearVelocity.y, -wallSlideSpeed));
        }
        else
        {
            isWallSliding = false;
        }
    }

    private void ProcessWallJump()
    {
        if(isWallSliding)
        {
            wallJumpDirection = -transform.localScale.x;
            wallJumpTimer = wallJumpTime;

            CancelInvoke(nameof(CancelWallJump));
        }
        else if (wallJumpTimer > 0f)
        {
            wallJumpTimer -= Time.deltaTime;
        }
    }

    private void CancelWallJump()
    {
        isWallJumping = false;
    }

    private void flip()
    {
        if (isFacingRight && horizontalMovement < 0 || !isFacingRight && horizontalMovement > 0)
        {
            isFacingRight = !isFacingRight;
            Vector3 ls = transform.localScale;
            ls.x *= -1f;
            transform.localScale = ls;

            if (rb.linearVelocity.y == 0f)
            {
                smokeFX.Play();
            } 
        }
    }

    private void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.white;
        Gizmos.DrawWireCube(groundCheckPos.position, groundCheckSize);
        Gizmos.color = Color.blue;
        Gizmos.DrawWireCube(wallCheckPos.position, wallCheckSize);
    }
}`
          },
          {
            language: "C#",
            title: "GameController.cs - Game Management",
            content: `using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;
using TMPro;

public class GameController : MonoBehaviour
{
    int progressAmount;
    public Slider progressSlider;
    public GameObject gameOverScreen;

    void OnEnable()
    {
        PlayerHealth.OnPlayerDied += GameOverScreen;
    }

    void OnDisable()
    {
        PlayerHealth.OnPlayerDied -= GameOverScreen;
    }

    void Start()
    {
        progressAmount = 0;
        progressSlider.value = 0;
        gameOverScreen.SetActive(false);

        Gem.OnGemCollect += IncreaseProgressAmount;
        HoldToLoadLevel.OnHoldComplete += LoadNextLevel;
    }

    void GameOverScreen()
    {
        gameOverScreen.SetActive(true);
        Time.timeScale = 0; // Pause the game
    }

    public void ResetGame()
    {
        Time.timeScale = 1; // Resume the game
        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex); // Reloads the current level
    }

    void IncreaseProgressAmount(int amount)
    {
        progressAmount += amount;
        progressSlider.value = progressAmount;
        if (progressAmount >= 100)
        {
            Debug.Log("Level Complete");
        }
    }

    void LoadNextLevel()
    {
        if (progressAmount >= 100)
        {
            SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex + 1);
        }
        else
        {
            Debug.Log("You need 100% progress to proceed!");
        }
    }
}`
          },
          {
            language: "C#",
            title: "Gem.cs - Collectible System",
            content: `using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Gem : MonoBehaviour, IITem
{
    public static event Action<int> OnGemCollect;
    public int worth = 5;
    
    public void Collect()
    {
        OnGemCollect.Invoke(worth); 
        Destroy(gameObject);
    }
}`
          },
          {
            language: "C#",
            title: "Collector.cs - Item Collection Handler",
            content: `using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Collector : MonoBehaviour
{
    private void OnTriggerEnter2D(Collider2D collision)
    {
        IITem item = collision.GetComponent<IITem>();
        if (item != null )
        {
            item.Collect();
        }
    }
}`
          },
          {
            language: "C#",
            title: "IITem.cs - Item Interface",
            content: `using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public interface IITem
{
    public void Collect();
}`
          }
        ],
        liveDemo: "#",
        sourceCode: "#"
      },
      {
        id: 17,
        title: "Space Shooter",
        description: "Retro-style space shooter where players dodge asteroids, defeat enemies, and collect power-ups for high scores.",
        category: "Games",
        image: "SC2.jpg",
        tags: ["Visual Studio Code", "Arcade Shooter"],
        fullDescription: "Built entirely in Visual Studio Code, this project features a retro-styled spaceship battle experience where players dodge asteroids, defeat enemies, and collect power-ups to survive longer and achieve higher scores. The game’s design emphasizes smooth gameplay, responsive controls, and pixel-perfect visuals that capture the nostalgia of old-school arcade games.",
        contribution: "Solo Developer - Programmed all game mechanics from scratch in Visual Studio Code, created sprite animations, implemented collision detection systems, designed enemy AI patterns, and developed the scoring and power-up systems.",
        features: [
          "Fast-paced and challenging arcade gameplay",
          "Dynamic enemy patterns and increasing difficulty",
          "Power-up and upgrade system for enhanced abilities",
          "Retro-inspired pixel art and space visuals",
          "High score tracking for competitive replayability"
        ],
        images: [
          "SC1.jpg",
          "SC2.jpg",
          "SC3.jpg",
          "SC4.jpg",
          "SC5.jpg"
        ],
        video: '<iframe src="https://drive.google.com/file/d/1OYMA6OVAEcyxVo2HKiDgOlDomQONDaPu/preview" width="100%" height="400" allow="autoplay"></iframe>',
        code: [
          {
            language: "C#",
            title: "Game1.cs - Main Game Class",
            content: `using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using System.Collections.Generic;

namespace Space_Shooting_FINALS
{
    public class Game1 : Game
    {
        private GraphicsDeviceManager graphics;
        private SpriteBatch spriteBatch;

        private Player player;
        private List<Enemy> enemies;
        private List<Bullet> bullets;
        private List<SpaceObject> spaceObjects;
        private Boss boss;

        private int playerScore;
        private int playerLives;

        public Game1()
        {
            graphics = new GraphicsDeviceManager(this);
            Content.RootDirectory = "Content";
        }

        protected override void Initialize()
        {
            base.Initialize();
            System.Diagnostics.Debug.WriteLine("Initialize started");

            // Initialize player, enemies, bullets, space objects, etc.
            player = new Player();
            enemies = new List<Enemy>();
            bullets = new List<Bullet>();
            spaceObjects = new List<SpaceObject>();
            boss = new Boss();

            // Populate enemies and space objects
            for (int i = 0; i < 10; i++)
            {
                enemies.Add(new Enemy());
            }

            for (int i = 0; i < 5; i++)
            {
                spaceObjects.Add(new SpaceObject());
            }

            playerScore = 0;
            playerLives = 3;

            System.Diagnostics.Debug.WriteLine("Initialize completed");
        }

        protected override void LoadContent()
        {
            spriteBatch = new SpriteBatch(GraphicsDevice);
            System.Diagnostics.Debug.WriteLine("LoadContent started");

            // Check if player is null before loading content
            if (player == null)
            {
                System.Diagnostics.Debug.WriteLine("Player is null in LoadContent method");
                return;
            }

            // Load player content
            player.LoadContent(Content);

            // Load content for enemies, space objects, and boss
            foreach (var enemy in enemies)
            {
                enemy.LoadContent(Content);
            }
            foreach (var spaceObject in spaceObjects)
            {
                spaceObject.LoadContent(Content);
            }
            boss.LoadContent(Content);

            System.Diagnostics.Debug.WriteLine("LoadContent completed");
        }

        protected override void Update(GameTime gameTime)
        {
            if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
                Exit();

            // Check if player is null before updating
            if (player == null)
            {
                System.Diagnostics.Debug.WriteLine("Player is null in Update method");
                return;
            }

            player.Update(gameTime);

            foreach (var enemy in enemies)
            {
                enemy.Update(gameTime);
            }

            foreach (var spaceObject in spaceObjects)
            {
                spaceObject.Update(gameTime);
            }

            foreach (var bullet in bullets)
            {
                bullet.Update(gameTime);
            }

            bullets.RemoveAll(b => !b.IsActive);

            boss.Update(gameTime);

            CheckCollisions();

            base.Update(gameTime);
        }

        protected override void Draw(GameTime gameTime)
        {
            GraphicsDevice.Clear(Color.CornflowerBlue);

            spriteBatch.Begin();

            // Check if player is null before drawing
            if (player != null)
            {
                player.Draw(spriteBatch);
            }
            else
            {
                System.Diagnostics.Debug.WriteLine("Player is null in Draw method");
            }

            foreach (var enemy in enemies)
            {
                enemy.Draw(spriteBatch);
            }
            foreach (var spaceObject in spaceObjects)
            {
                spaceObject.Draw(spriteBatch);
            }
            boss.Draw(spriteBatch);

            spriteBatch.DrawString(Content.Load<SpriteFont>("font"), "Score: " + playerScore, new Vector2(10, 10), Color.White);
            spriteBatch.DrawString(Content.Load<SpriteFont>("font"), "Lives: " + playerLives, new Vector2(10, 30), Color.White);

            spriteBatch.End();

            base.Draw(gameTime);
        }

        private void CheckCollisions()
        {
            foreach (var bullet in bullets)
            {
                foreach (var enemy in enemies)
                {
                    if (bullet.BoundingBox.Intersects(enemy.BoundingBox))
                    {
                        bullet.IsActive = false;
                        enemies.Remove(enemy);
                        playerScore += 10;
                        break;
                    }
                }

                if (bullet.BoundingBox.Intersects(boss.BoundingBox))
                {
                    bullet.IsActive = false;
                    boss.Health -= 10;
                    if (boss.Health <= 0)
                    {
                        playerScore += 100;
                        // Handle boss defeat
                    }
                }
            }

            foreach (var enemy in enemies)
            {
                if (player.BoundingBox.Intersects(enemy.BoundingBox))
                {
                    player.Health -= 10;
                    enemies.Remove(enemy);
                    if (player.Health <= 0)
                    {
                        // Handle player defeat
                    }
                }
            }

            if (player.BoundingBox.Intersects(boss.BoundingBox))
            {
                player.Health -= 50;
                if (player.Health <= 0)
                {
                    // Handle player defeat
                }
            }
        }
    }
}`
          },
          {
            language: "C#",
            title: "Player.cs - Player Character",
            content: `using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;

namespace Space_Shooting_FINALS
{
    public class Player
    {
        public Texture2D Texture;
        public Vector2 Position;
        public float Speed;
        public int Health;

        public void LoadContent(ContentManager content)
        {
            Texture = content.Load<Texture2D>("playerTexture");
            Position = new Vector2(400, 500); // Example starting position
            Speed = 5f;
            Health = 100;
        }

        public void Update(GameTime gameTime)
        {
            // Handle player movement
            KeyboardState state = Keyboard.GetState();
            if (state.IsKeyDown(Keys.W))
                Position.Y -= Speed;
            if (state.IsKeyDown(Keys.S))
                Position.Y += Speed;
            if (state.IsKeyDown(Keys.A))
                Position.X -= Speed;
            if (state.IsKeyDown(Keys.D))
                Position.X += Speed;

            // Keep player within the screen bounds
            Position.X = MathHelper.Clamp(Position.X, 0, 800 - Texture.Width);
            Position.Y = MathHelper.Clamp(Position.Y, 0, 600 - Texture.Height);
        }

        public void Draw(SpriteBatch spriteBatch)
        {
            spriteBatch.Draw(Texture, Position, Color.White);
        }

        public Rectangle BoundingBox
        {
            get { return new Rectangle((int)Position.X, (int)Position.Y, Texture.Width, Texture.Height); }
        }
    }
}`
          },
          {
            language: "C#",
            title: "Enemy.cs - Enemy AI",
            content: `using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;

public class Enemy
{
    public Texture2D Texture;
    public Vector2 Position;
    public float Speed;

    public void LoadContent(ContentManager content)
    {
        Texture = content.Load<Texture2D>("enemyTexture");
        Position = new Vector2(400, 100); // Example starting position
        Speed = 2f;
    }

    public void Update(GameTime gameTime)
    {
        // Handle enemy movement
        Position.Y += Speed;

        // Reset position if off screen
        if (Position.Y > 600)
            Position.Y = -Texture.Height;
    }

    public void Draw(SpriteBatch spriteBatch)
    {
        spriteBatch.Draw(Texture, Position, Color.White);
    }

    public Rectangle BoundingBox
    {
        get { return new Rectangle((int)Position.X, (int)Position.Y, Texture.Width, Texture.Height); }
    }
}`
          },
          {
            language: "C#",
            title: "Boss.cs - Boss Enemy",
            content: `using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;

public class Boss
{
    public Texture2D Texture;
    public Vector2 Position;
    public float Speed;
    public int Health;

    public void LoadContent(ContentManager content)
    {
        Texture = content.Load<Texture2D>("bossTexture");
        Position = new Vector2(400, 50); // Example starting position
        Speed = 1f;
        Health = 500;
    }

    public void Update(GameTime gameTime)
    {
        // Handle boss movement and behavior
        // Example: move left and right
        Position.X += Speed;
        if (Position.X < 0 || Position.X > 800 - Texture.Width)
            Speed = -Speed;
    }

    public void Draw(SpriteBatch spriteBatch)
    {
        spriteBatch.Draw(Texture, Position, Color.White);
    }

    public Rectangle BoundingBox
    {
        get { return new Rectangle((int)Position.X, (int)Position.Y, Texture.Width, Texture.Height); }
    }
}`
          },
          {
            language: "C#",
            title: "Bullet.cs - Projectile System",
            content: `using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;

public class Bullet
{
    public Texture2D Texture;
    public Vector2 Position;
    public float Speed;
    public bool IsActive { get; set; }

    public void LoadContent(ContentManager content)
    {
        Texture = content.Load<Texture2D>("bulletTexture");
        Speed = 10f;
        IsActive = true;
    }

    public void Update(GameTime gameTime)
    {
        // Handle bullet movement
        Position.Y -= Speed;

        // Deactivate bullet if off screen
        if (Position.Y < -Texture.Height)
        {
            IsActive = false;
        }
    }

    public void Draw(SpriteBatch spriteBatch)
    {
        if (IsActive)
        {
            spriteBatch.Draw(Texture, Position, Color.White);
        }
    }

    public Rectangle BoundingBox
    {
        get { return new Rectangle((int)Position.X, (int)Position.Y, Texture.Width, Texture.Height); }
    }
}`
          },
          {
            language: "C#",
            title: "SpaceObject.cs - Background Objects",
            content: `using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;

public class SpaceObject
{
    public Texture2D Texture;
    public Vector2 Position;
    public float Speed;

    public void LoadContent(ContentManager content)
    {
        Texture = content.Load<Texture2D>("spaceObjectTexture");
        Position = new Vector2(new System.Random().Next(0, 800), new System.Random().Next(0, 600)); // Random position
        Speed = new System.Random().Next(1, 5); // Random speed
    }

    public void Update(GameTime gameTime)
    {
        // Handle space object movement
        Position.Y += Speed;

        // Reset position if off screen
        if (Position.Y > 600)
            Position.Y = -Texture.Height;
    }

    public void Draw(SpriteBatch spriteBatch)
    {
        spriteBatch.Draw(Texture, Position, Color.White);
    }

    public Rectangle BoundingBox
    {
        get { return new Rectangle((int)Position.X, (int)Position.Y, Texture.Width, Texture.Height); }
    }
}`
          },
          {
            language: "C#",
            title: "Program.cs - Entry Point",
            content: `using System;

namespace Space_Shooting_FINALS // Ensure this matches your project namespace
{
    public static class Program
    {
        [STAThread]
        static void Main()
        {
            using (var game = new Game1())
                game.Run();
        }
    }
}`
          }
        ],
        liveDemo: "#",
        sourceCode: "#"
      },
      {
        id: 18,
        title: "Hangman",
        description: "A C++-based word-guessing game with educational themes and progressive levels.",
        category: "Games",
        image: "HM1.jpg",
        tags: ["C++", "Educational Game", "PC Game"],
        fullDescription: "A classic Hangman game developed in C++ featuring multiple word categories, progressive difficulty, and educational value. Designed for PC, it uses ASCII visuals, color-coded feedback, and structured programming principles to create an engaging learning experience. The project highlights proficiency in control flow, data structures, and exception handling for interactive console-based applications.",
        contribution: "Solo Developer - Designed and implemented complete game architecture in C++, created educational word databases, developed ASCII art system, programmed difficulty progression algorithms, and implemented comprehensive error handling and scoring mechanisms.",
        features: [
          "Classic Hangman gameplay in C++",
          "Educational word categories (Animals, Food, Sports and, Country.)",
          "Progressive difficulty levels",
          "Color-coded feedback and ASCII visuals",
          "Score tracking with structured logic and error handling"
        ],
        images: [
          "HM1.jpg",
          "HM2.jpg",
          "HM3.jpg",
          "HM4.jpg",
          "HM5.jpg"
        ],
        video: `<iframe src="https://drive.google.com/file/d/1N53ob5iLYfp57_f3UG8P8voLxh4pRQzT/preview" allow="autoplay" allowfullscreen></iframe>`,
        code: [
          {
            language: "C++",
            title: "main.cpp - Complete Hangman Game",
            content: `#include <iostream>
#include <string>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <stack>
#include <queue>
#include <limits>

#ifdef _WIN32
    #define CLEAR_SCREEN "cls"
#else
    #define CLEAR_SCREEN "clear"
#endif

// Function prototypes
bool isGuessCorrect(const std::string& word, std::string& guessedWord, char guess);
bool isGameWon(const std::string& word, const std::string& guessedWord);
void displayHangman(int incorrectGuesses);
void displayGuessedLettersStack(const std::stack<char>& guessedLettersStack);
void displayGuessedLettersQueue(const std::queue<char>& guessedLettersQueue);
void displayCategories();
std::vector<std::string> getWordBank(int categoryChoice);
bool playHangman(const std::vector<std::string>& wordBank, int currentLevel);

bool isGuessCorrect(const std::string& word, std::string& guessedWord, char guess) {
    bool correctGuess = false;
    for (size_t i = 0; i < word.length(); ++i) {
        if (word[i] == guess) {
            guessedWord[i] = guess;
            correctGuess = true;
        }
    }
    return correctGuess;
}

bool isGameWon(const std::string& word, const std::string& guessedWord) {
    return word == guessedWord;
}

void displayHangman(int incorrectGuesses) {
    std::cout << " ___" << std::endl;
    std::cout << " |     |" << std::endl;
    switch (incorrectGuesses) {
        case 0:
            std::cout << " |" << std::endl;
            std::cout << " |" << std::endl;
            std::cout << " |" << std::endl;
            std::cout << " |" << std::endl;
            break;
        case 1:
            std::cout << " |     O" << std::endl;
            std::cout << " |" << std::endl;
            std::cout << " |" << std::endl;
            std::cout << " |" << std::endl;
            break;
        case 2:
            std::cout << " |     O" << std::endl;
            std::cout << " |     |" << std::endl;
            std::cout << " |" << std::endl;
            std::cout << " |" << std::endl;
            break;
        case 3:
            std::cout << " |     O" << std::endl;
            std::cout << " |    /|" << std::endl;
            std::cout << " |" << std::endl;
            std::cout << " |" << std::endl;
            break;
        case 4:
            std::cout << " |     O" << std::endl;
            std::cout << " |    /|\\\\" << std::endl;
            std::cout << " |" << std::endl;
            std::cout << " |" << std::endl;
            break;
        case 5:
            std::cout << " |     O" << std::endl;
            std::cout << " |    /|\\\\" << std::endl;
            std::cout << " |    /" << std::endl;
            std::cout << " |" << std::endl;
            break;
        case 6:
            std::cout << " |     O" << std::endl;
            std::cout << " |    /|\\\\" << std::endl;
            std::cout << " |    / \\\\" << std::endl;
            std::cout << " |" << std::endl;
            break;
        default:
            break;
    }
    std::cout << " |" << std::endl;
    std::cout << "==========" << std::endl;
}

void displayGuessedLettersStack(const std::stack<char>& guessedLettersStack) {
    std::stack<char> tempStack = guessedLettersStack;
    while (!tempStack.empty()) {
        std::cout << tempStack.top() << " ";
        tempStack.pop();
    }
}

void displayGuessedLettersQueue(const std::queue<char>& guessedLettersQueue) {
    std::queue<char> tempQueue = guessedLettersQueue;
    while (!tempQueue.empty()) {
        std::cout << tempQueue.front() << " ";
        tempQueue.pop();
    }
}

void displayColoredLetters(const std::string& word, const std::string& guessedWord, const std::string& guessedLetters) {
    for (size_t i = 0; i < word.length(); ++i) {
        if (guessedWord[i] == word[i]) {
            std::cout << "\\033[32m" << guessedWord[i] << "\\033[0m ";
        } else {
            if (guessedLetters.find(word[i]) != std::string::npos) {
                std::cout << "\\033[31m" << guessedWord[i] << "\\033[0m ";
            } else {
                std::cout << guessedWord[i] << " ";
            }
        }
    }
    std::cout << std::endl;
}

void displayAlphabet(const std::string& guessedLetters) {
    std::cout << "Available letters: ";
    for (char c = 'a'; c <= 'z'; ++c) {
        if (guessedLetters.find(c) != std::string::npos) {
            std::cout << "\\033[31m" << c << "\\033[0m ";
        } else {
            std::cout << "\\033[32m" << c << "\\033[0m ";
        }
    }
    std::cout << std::endl;
}

void displayCategories() {
    std::cout << "\\033[32m"; // Set text color to green
    std::cout << "=====================" << std::endl;
    std::cout << "       HANGMAN" << std::endl;
    std::cout << "=====================" << std::endl;
    std::cout << "\\033[0m";  // Reset colors to default
    std::cout << "\\033[92m1. Animals\\033[0m" << std::endl;
    std::cout << "\\033[92m2. Countries\\033[0m" << std::endl;
    std::cout << "\\033[92m3. Food\\033[0m" << std::endl;
    std::cout << "\\033[92m4. Sports\\033[0m" << std::endl;

    std::cout << "\\033[32m\\nEnter the corresponding number: \\033[0m";
}

std::vector<std::string> getWordBank(int categoryChoice) {
    std::vector<std::string> wordBank;
    switch (categoryChoice) {
        case 1:
            wordBank = {"lion", "The king of the jungle", "elephant", "The largest land animal", "tiger", "A big cat with stripes", "giraffe", "Tall-necked animal", "monkey", "Primate known for swinging"};
            break;
        case 2:
            wordBank = {"japan", "Land of the rising sun", "canada", "Home to maple syrup", "australia", "Country of kangaroos", "brazil", "Famous for the Amazon rainforest", "france", "Known for the Eiffel Tower"};
            break;
        case 3:
            wordBank = {"pizza", "Popular Italian dish", "hamburger", "Classic fast food", "sushi", "Japanese cuisine with raw fish", "pasta", "Italian noodle dish", "chocolate", "Sweet treat made from cocoa"};
            break;
        case 4:
            wordBank = {"soccer", "Global sport also known as football", "basketball", "Game with hoops and a ball", "tennis", "Racket sport played on a court", "golf", "Sport played with clubs and balls", "swimming", "Activity done in water"};
            break;
        default:
            break;
    }
    return wordBank;
}

bool playHangman(const std::vector<std::string>& wordBank, int currentLevel) {
    static int totalScore = 0;  // Declare totalScore as static to retain its value across function calls
    int levelScore = 0;
    std::srand(static_cast<unsigned int>(std::time(nullptr)));

    std::string selectedWord = wordBank[(currentLevel - 1) * 2];
    std::string guessedWord(selectedWord.length(), '-');

    int incorrectGuesses = 0;
    std::string guessedLetters;
    std::stack<char> guessedLettersStack;
    std::queue<char> guessedLettersQueue;
    

    while (incorrectGuesses < 6) {
        std::system(CLEAR_SCREEN);

        std::cout << "================" << std::endl;
        std::cout << "==   LEVEL " << currentLevel << "  ==" << std::endl;
        std::cout << "================" << std::endl;
        std::cout << "Clue: " << wordBank[(currentLevel - 1) * 2 + 1] << std::endl;
        std::cout << "Guessed Word: " << guessedWord << std::endl;
        std::cout << "Incorrect Guesses: " << incorrectGuesses << "/6" << std::endl;
        displayHangman(incorrectGuesses);
        std::cout << std::endl;
        displayAlphabet(guessedLetters);

        std::cout << "Guess a letter: ";

        char guess;
        std::cin >> guess;

        try {
            if (!std::isalpha(guess)) {
                throw std::invalid_argument("Invalid guess. Please enter a letter.");
            }

            guess = std::tolower(guess);

            if (guessedLetters.find(guess) != std::string::npos) {
                throw std::invalid_argument("You have already guessed that letter. Try again.");
            }

            guessedLetters += guess;
            guessedLettersStack.push(guess);
            guessedLettersQueue.push(guess);

            if (isGuessCorrect(selectedWord, guessedWord, guess)) {
                std::cout << "Correct guess!" << std::endl;
                if (isGameWon(selectedWord, guessedWord)) {
                    std::system(CLEAR_SCREEN);
                    std::cout << "======================================" << std::endl;
                    std::cout << "CONGRATULATIONS! YOU GUESSED IT RIGHT!" << std::endl;
                    std::cout << "          The word is: " << selectedWord << std::endl;
                    levelScore = 20 - incorrectGuesses;
                    std::cout << "            Level score: " << levelScore << std::endl;
                    totalScore += levelScore;  // Accumulate the level score to the total score
                    std::cout << "            Total score: " << totalScore << std::endl;
                    std::cout << "======================================" << std::endl;
                    std::cout << "\\nLetters guessed in stack order: ";
                    displayGuessedLettersStack(guessedLettersStack);
                    std::cout << std::endl;
                    std::cout << "\\nLetters guessed in queue order: ";
                    displayGuessedLettersQueue(guessedLettersQueue);
                    std::cout << std::endl;

                    char choice;
                    bool validChoice = false;

                    while (!validChoice) {
                        std::cout << "\\nDo you want to move to the next level? (y/n): ";

                        try {
                            std::cin >> choice;
                            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');  // Clear input buffer

                            choice = std::tolower(choice);

                            if (choice != 'y' && choice != 'n') {
                                throw std::runtime_error("Invalid choice. Please enter 'y' or 'n'.");
                                std::cin.clear();
                            }

                            validChoice = true;
                        } catch (const std::exception& e) {
                            std::cout << "Error: " << e.what() << std::endl;
                            std::cin.clear();
                            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');
                        }
                    }

                    return (choice == 'y');
                }
            } else {
                std::cout << "Incorrect guess!" << std::endl;
                ++incorrectGuesses;
            }
        } catch (const std::exception& e) {
            std::cout << "Error: " << e.what() << std::endl;
            std::cin.clear();
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');
        }
    }

    std::system(CLEAR_SCREEN);
    std::cout << "You lost! The word was: " << selectedWord << std::endl;
    std::cout << "\\n _____" << std::endl;
    std::cout << " |     |" << std::endl;
    std::cout << " |     O" << std::endl;
    std::cout << " |    /|\\\\" << std::endl;
    std::cout << " |    / \\\\" << std::endl;
    std::cout << " |" << std::endl;
    std::cout << " |" << std::endl;
    std::cout << "==========" << std::endl;

    char choice;
    std::cout << "Do you want to try again? (y/n): ";
    std::cin >> choice;

    return (tolower(choice) == 'y');
}

int main() {
    int categoryChoice = 0;
    bool playAgain = true;
    int currentLevel = 1;

    while (playAgain && currentLevel <= 5) {
        std::system(CLEAR_SCREEN);

        if (currentLevel == 1) {
            displayCategories();
            std::cin >> categoryChoice;

            try {
                if (categoryChoice < 1 || categoryChoice > 4) {
                    throw std::out_of_range("Invalid category choice. Please try again.");
                }
            } catch (const std::exception& e) {
                std::cout << "Error: " << e.what() << std::endl;
                std::cin.clear();
                std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');
                continue;
            }
        }

        std::vector<std::string> wordBank = getWordBank(categoryChoice);

        std::cout << "=====================" << std::endl;
        std::cout << "==   LEVEL " << currentLevel << " START   ==" << std::endl;
        std::cout << "=====================" << std::endl;

        playAgain = playHangman(wordBank, currentLevel);
        if (playAgain) {
            ++currentLevel;
        }
    }

    std::cout << "Oops! That is the last level! Thank you for playing Hangman!" << std::endl;

    return 0;
}`
          }
        ],
        liveDemo: "#",
        sourceCode: "#"
      },
      {
        id: 21,
        title: "Lucid Dreams",
       description: "A bizarre and hilarious dream world where reality breaks and furnitures fight back.",
        category: "Games",
        image: "LD2.jpg",
        tags: ["C#", "Unity", "Action"],
        fullDescription: "Lucid Dreams throws players into a wild, dreamlike world where logic doesn’t exist, and the most unexpected things can become enemies. Fight absurd objects like sentient appliances, explore chaotic dreamscapes, and survive ridiculous encounters in a physics-driven sandbox filled with humor and unpredictability. Every dream is a new story of chaos and laughter.",
        contribution: "Lead Developer - Designed and implemented the dream world physics system, created comedic AI behaviors for household objects, developed ragdoll combat mechanics, built procedural dream event systems, and crafted the surreal visual style and interactive environments.",
        features: [
           "Dynamic ragdoll physics and comedic combat",
           "Surreal enemies like possessed household objects",
           "Expansive open environments with sandbox interactions",
           "Unpredictable dream logic and events",
           "Light-hearted humor mixed with action gameplay",
           "Built in Unity with stylized low-poly visuals"
        ],
        images: [
          "LD1.jpg",
          "LD2.jpg",
          "LD3.jpg",
          "LD4.jpg",
          "LD5.jpg",
          "LD6.jpg",
          "LD7.jpg",
          "LD8.jpg",
          "LD9.jpg"
        ],
        video: `<iframe src="https://drive.google.com/file/d/1kv063gbKzSJPvY0CWHXFyyK4QKNBzn87/preview" allow="autoplay" allowfullscreen></iframe>`,
        code: [
          {
            language: "C#",
            title: "DreamController.cs - Main Dream Navigation System",
            content: `using UnityEngine;
using System.Collections;

public class DreamController : MonoBehaviour
{
    [Header("Dream Environment Settings")]
    public Transform player;
    public Transform[] dreamLayers;
    public Material[] dreamMaterials;
    public Light dreamLight;
    
    [Header("Physics Settings")]
    public float gravityMultiplier = 0.5f;
    public float floatForce = 10f;
    
    private bool isLucidMode = false;
    private float timeInDream = 0f;
    
    void Start()
    {
        // Initialize dream physics
        Physics.gravity *= gravityMultiplier;
        StartCoroutine(DreamCycle());
    }
    
    void Update()
    {
        timeInDream += Time.deltaTime;
        UpdateDreamState();
        HandleLucidMode();
    }
    
    void UpdateDreamState()
    {
        // Cycle through dream materials for morphing effect
        float cycleTime = Mathf.Sin(timeInDream * 0.1f);
        
        foreach (var layer in dreamLayers)
        {
            if (layer != null)
            {
                var renderer = layer.GetComponent<Renderer>();
                if (renderer != null)
                {
                    renderer.material.SetFloat("_TimeOffset", cycleTime);
                }
            }
        }
        
        // Dynamic lighting changes
        if (dreamLight != null)
        {
            dreamLight.intensity = Mathf.Lerp(0.5f, 2f, 
                (Mathf.Sin(timeInDream * 0.05f) + 1f) / 2f);
            
            dreamLight.color = Color.Lerp(
                Color.blue, Color.magenta,
                (Mathf.Cos(timeInDream * 0.03f) + 1f) / 2f
            );
        }
    }
    
    void HandleLucidMode()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            ToggleLucidMode();
        }
        
        if (isLucidMode)
        {
            // Allow player to manipulate dream environment
            if (Input.GetMouseButtonDown(0))
            {
                Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
                RaycastHit hit;
                
                if (Physics.Raycast(ray, out hit))
                {
                    StartCoroutine(DreamObjectManipulation(hit.collider.gameObject));
                }
            }
        }
    }
    
    void ToggleLucidMode()
    {
        isLucidMode = !isLucidMode;
        
        if (isLucidMode)
        {
            Debug.Log("Lucid mode activated - Reality bends to your will");
            Time.timeScale = 0.7f; // Slow down time
        }
        else
        {
            Debug.Log("Returning to normal dream state");
            Time.timeScale = 1f;
        }
    }
    
    IEnumerator DreamCycle()
    {
        while (true)
        {
            // Random dream events
            yield return new WaitForSeconds(Random.Range(10f, 30f));
            TriggerDreamEvent();
        }
    }
    
    void TriggerDreamEvent()
    {
        int eventType = Random.Range(0, 3);
        
        switch (eventType)
        {
            case 0:
                StartCoroutine(GravityShift());
                break;
            case 1:
                StartCoroutine(EnvironmentMorph());
                break;
            case 2:
                StartCoroutine(ColorFlash());
                break;
        }
    }
    
    IEnumerator DreamObjectManipulation(GameObject obj)
    {
        Vector3 originalPos = obj.transform.position;
        Vector3 targetPos = originalPos + Vector3.up * 5f;
        
        float duration = 2f;
        float elapsed = 0f;
        
        while (elapsed < duration)
        {
            float t = elapsed / duration;
            obj.transform.position = Vector3.Lerp(originalPos, targetPos, 
                Mathf.Sin(t * Mathf.PI));
            
            elapsed += Time.deltaTime;
            yield return null;
        }
        
        obj.transform.position = originalPos;
    }
    
    IEnumerator GravityShift()
    {
        Vector3 originalGravity = Physics.gravity;
        Vector3 newGravity = new Vector3(
            Random.Range(-10f, 10f),
            Random.Range(-20f, 5f),
            Random.Range(-10f, 10f)
        );
        
        float duration = 5f;
        float elapsed = 0f;
        
        while (elapsed < duration)
        {
            Physics.gravity = Vector3.Lerp(originalGravity, newGravity, 
                Mathf.Sin((elapsed / duration) * Mathf.PI));
            
            elapsed += Time.deltaTime;
            yield return null;
        }
        
        Physics.gravity = originalGravity;
    }
    
    IEnumerator EnvironmentMorph()
    {
        foreach (var layer in dreamLayers)
        {
            if (layer != null)
            {
                StartCoroutine(MorphLayer(layer));
            }
        }
        
        yield return new WaitForSeconds(3f);
    }
    
    IEnumerator MorphLayer(Transform layer)
    {
        Vector3 originalScale = layer.localScale;
        Vector3 morphScale = originalScale * Random.Range(0.5f, 2f);
        
        float duration = 3f;
        float elapsed = 0f;
        
        while (elapsed < duration)
        {
            float t = elapsed / duration;
            layer.localScale = Vector3.Lerp(originalScale, morphScale, 
                Mathf.Sin(t * Mathf.PI));
            
            elapsed += Time.deltaTime;
            yield return null;
        }
        
        layer.localScale = originalScale;
    }
    
    IEnumerator ColorFlash()
    {
        Color originalColor = dreamLight.color;
        Color flashColor = new Color(
            Random.Range(0f, 1f),
            Random.Range(0f, 1f),
            Random.Range(0f, 1f)
        );
        
        // Quick flash
        dreamLight.color = flashColor;
        yield return new WaitForSeconds(0.1f);
        dreamLight.color = originalColor;
    }
    
    void OnDrawGizmos()
    {
        if (isLucidMode)
        {
            Gizmos.color = Color.cyan;
            Gizmos.DrawWireSphere(player.position, 10f);
        }
    }
}`
          }
        ],
        liveDemo: "#",
        sourceCode: "#"
      }
    ];

    let currentFilter = 'All';
    let currentPage = 1;
    const projectsPerPage = 8;

    // Smooth scrolling function
    function scrollToSection(id) {
      const element = document.getElementById(id);
      if (element) {
        element.scrollIntoView({behavior: 'smooth'});
        closeMobileMenu();
      }
    }

    // Header scroll animation
    let scrollTimeout;
    
    function handleNavScroll() {
      const nav = document.querySelector('.nav');
      const currentScroll = window.pageYOffset || document.documentElement.scrollTop;
      
      // Add scrolled class when scrolled down (minimizes the header)
      if (currentScroll > 50) {
        nav.classList.add('scrolled');
      } else {
        nav.classList.remove('scrolled');
      }
      
      // Remove the hidden class logic - header should always stay visible
      nav.classList.remove('hidden');
    }
    
    // Throttled scroll listener for better performance
    window.addEventListener('scroll', () => {
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }
      scrollTimeout = setTimeout(handleNavScroll, 10);
    });

    // Initialize nav on page load
    document.addEventListener('DOMContentLoaded', () => {
      handleNavScroll();
      // Initialize projects display with pagination
      filterProjects('All');
    });

    // Mobile menu toggle
    function toggleMobileMenu() {
      const mobileNav = document.getElementById('mobileNav');
      mobileNav.classList.toggle('open');
    }

    function closeMobileMenu() {
      const mobileNav = document.getElementById('mobileNav');
      mobileNav.classList.remove('open');
    }

    // Project filtering
    function filterProjects(category) {
      currentFilter = category;
      currentPage = 1; // Reset to first page when filtering

      // Update filter buttons
      const buttons = document.querySelectorAll('.filter-button');
      buttons.forEach(button => {
        button.classList.remove('active');
        if (button.textContent === category) {
          button.classList.add('active');
        }
      });

      // Filter and display projects
      const filteredProjects = category === 'All' ? projects : projects.filter(p => p.category === category);
      displayProjects(filteredProjects);
      updatePagination(filteredProjects);
    }

    // Display projects with pagination
    function displayProjects(allProjects) {
      const grid = document.getElementById('projectsGrid');
      
      // For "All" category, apply pagination
      if (currentFilter === 'All') {
        const startIndex = (currentPage - 1) * projectsPerPage;
        const endIndex = startIndex + projectsPerPage;
        const projectsToShow = allProjects.slice(startIndex, endIndex);
        
        grid.innerHTML = projectsToShow.map(project => `
          <div class="project-card" onclick="openProjectModal(${project.id})">
            <div class="relative">
              <img src="${project.image}" alt="${project.title}" class="project-image">
              <div class="category-badge">${project.category}</div>
            </div>
            <div class="project-content">
              <h3 class="project-title">${project.title}</h3>
              <p class="project-description">${project.description}</p>
              <div class="project-tags">
                ${project.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
              </div>
            </div>
          </div>
        `).join('');
      } else {
        // For specific categories, show all projects without pagination
        grid.innerHTML = allProjects.map(project => `
          <div class="project-card" onclick="openProjectModal(${project.id})">
            <div class="relative">
              <img src="${project.image}" alt="${project.title}" class="project-image">
              <div class="category-badge">${project.category}</div>
            </div>
            <div class="project-content">
              <h3 class="project-title">${project.title}</h3>
              <p class="project-description">${project.description}</p>
              <div class="project-tags">
                ${project.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
              </div>
            </div>
          </div>
        `).join('');
      }
    }

    // Update pagination controls
    function updatePagination(allProjects) {
      const pagination = document.getElementById('pagination');
      const pageNumbers = document.getElementById('pageNumbers');
      const prevBtn = document.getElementById('prevPage');
      const nextBtn = document.getElementById('nextPage');

      // Only show pagination for "All" category and if there are more than projectsPerPage projects
      if (currentFilter === 'All' && allProjects.length > projectsPerPage) {
        pagination.style.display = 'flex';
        
        const totalPages = Math.ceil(allProjects.length / projectsPerPage);
        
        // Update previous button
        prevBtn.disabled = currentPage === 1;
        
        // Update next button
        nextBtn.disabled = currentPage === totalPages;
        
        // Generate page numbers
        let pageNumbersHTML = '';
        const maxVisiblePages = 5;
        let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
        let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
        
        // Adjust start page if we're near the end
        if (endPage - startPage + 1 < maxVisiblePages) {
          startPage = Math.max(1, endPage - maxVisiblePages + 1);
        }
        
        // Add first page and ellipsis if needed
        if (startPage > 1) {
          pageNumbersHTML += `<span class="page-number" onclick="goToPage(1)">1</span>`;
          if (startPage > 2) {
            pageNumbersHTML += `<span class="page-ellipsis">...</span>`;
          }
        }
        
        // Add visible page numbers
        for (let i = startPage; i <= endPage; i++) {
          pageNumbersHTML += `<span class="page-number ${i === currentPage ? 'active' : ''}" onclick="goToPage(${i})">${i}</span>`;
        }
        
        // Add ellipsis and last page if needed
        if (endPage < totalPages) {
          if (endPage < totalPages - 1) {
            pageNumbersHTML += `<span class="page-ellipsis">...</span>`;
          }
          pageNumbersHTML += `<span class="page-number" onclick="goToPage(${totalPages})">${totalPages}</span>`;
        }
        
        pageNumbers.innerHTML = pageNumbersHTML;
      } else {
        pagination.style.display = 'none';
      }
    }

    // Change page function
    function changePage(direction) {
      const filteredProjects = currentFilter === 'All' ? projects : projects.filter(p => p.category === currentFilter);
      const totalPages = Math.ceil(filteredProjects.length / projectsPerPage);
      
      const newPage = currentPage + direction;
      if (newPage >= 1 && newPage <= totalPages) {
        currentPage = newPage;
        displayProjects(filteredProjects);
        updatePagination(filteredProjects);
        
        // Scroll to projects section
        document.getElementById('projects').scrollIntoView({ behavior: 'smooth' });
      }
    }

    // Go to specific page
    function goToPage(page) {
      const filteredProjects = currentFilter === 'All' ? projects : projects.filter(p => p.category === currentFilter);
      const totalPages = Math.ceil(filteredProjects.length / projectsPerPage);
      
      if (page >= 1 && page <= totalPages) {
        currentPage = page;
        displayProjects(filteredProjects);
        updatePagination(filteredProjects);
        
        // Scroll to projects section
        document.getElementById('projects').scrollIntoView({ behavior: 'smooth' });
      }
    }

    // Project Modal Functions
    function openProjectModal(projectId) {
      const project = projects.find(p => p.id === projectId);
      if (!project) return;

      // Add opening animation class
      document.body.style.overflow = 'hidden';
      
      // Mobile-specific handling
      const isMobile = window.innerWidth <= 768;
      
      // Check if this is a 3D Models project
      const is3DModel = project.category === '3D Models';
      
      // Populate modal content
      document.getElementById('modalTitle').textContent = project.title;
      const mainImage = document.getElementById('modalMainImage');
      mainImage.src = project.image;
      mainImage.alt = project.title;
      mainImage.onclick = () => openImagePreview(project.image);
      mainImage.style.cursor = 'pointer';
      document.getElementById('modalDescription').textContent = project.fullDescription || project.description;
      
      // Update contribution field
      const contributionContainer = document.getElementById('modalContribution');
      if (project.contribution) {
        contributionContainer.style.display = 'block';
        contributionContainer.querySelector('p').textContent = project.contribution;
      } else {
        contributionContainer.style.display = 'none';
      }
      
      // Update tags with staggered animation
      const tagsContainer = document.getElementById('modalTags');
      tagsContainer.innerHTML = project.tags.map((tag, index) => 
        `<span class="tag" style="animation-delay: ${index * 0.1}s; animation: fadeInScale 0.5s ease-out ${index * 0.1}s both;">${tag}</span>`
      ).join('');
      
      // Update features with animation
      const featuresContainer = document.getElementById('modalFeatures');
      if (project.features) {
        featuresContainer.innerHTML = `
          <div class="mb-4">
            <h4 class="text-xl font-semibold mb-3" style="animation: fadeInUp 0.6s ease-out 0.2s both;">Key Features</h4>
            <ul style="list-style: ${isMobile ? 'none' : 'disc'}; margin-left: ${isMobile ? '0' : '1.5rem'}; color: var(--muted-foreground);">
              ${project.features.map((feature, index) => 
                `<li class="mb-2" style="animation: fadeInLeft 0.5s ease-out ${0.3 + index * 0.1}s both; ${isMobile ? 'padding-left: 1.5rem; position: relative;' : ''}">${feature}</li>`
              ).join('')}
            </ul>
          </div>
        `;
      } else {
        featuresContainer.innerHTML = '';
      }

      // Update links
      document.getElementById('liveDemoLink').href = project.liveDemo || '#';
      
      // Hide/show source code button based on project category
      const sourceCodeLink = document.getElementById('sourceCodeLink');
      const isAnimation = project.category === 'Animations';
      
      if (is3DModel || isAnimation) {
        sourceCodeLink.style.display = 'none';
      } else {
        sourceCodeLink.style.display = 'flex';
        sourceCodeLink.href = project.sourceCode || '#';
      }

      // Hide/show tabs based on project category
      const videosTab = document.querySelector('button[onclick="switchTab(\'videos\')"]');
      const codeTab = document.querySelector('button[onclick="switchTab(\'code\')"]');
      
      if (is3DModel) {
        // Hide Video and Code tabs for 3D Models
        if (videosTab) videosTab.style.display = 'none';
        if (codeTab) codeTab.style.display = 'none';
      } else if (isAnimation) {
        // Show Video tab but hide Code tab for Animations
        if (videosTab) videosTab.style.display = 'block';
        if (codeTab) codeTab.style.display = 'none';
      } else {
        // Show Video and Code tabs for other projects
        if (videosTab) videosTab.style.display = 'block';
        if (codeTab) codeTab.style.display = 'block';
      }

      // Populate image gallery
      populateImageGallery(project.images || [project.image]);
      
      // Populate video content
      populateVideoContent(project.video || '');
      
      // Populate code blocks (only if not 3D Model or Animation)
      if (!is3DModel && !isAnimation) {
        populateCodeBlocks(project.code || []);
      }
      
      // Show modal with enhanced animation
      const modal = document.getElementById('projectModal');
      modal.classList.add('active');
      
      // Add particle effect (desktop only)
      if (!isMobile) {
        createModalParticles();
      }
      
      // Switch to overview tab
      switchTab('overview');
      
      // Scroll to top of modal on mobile
      if (isMobile) {
        setTimeout(() => {
          const modalContent = modal.querySelector('.modal-content');
          modalContent.scrollTop = 0;
        }, 100);
      }
    }

    function closeProjectModal() {
      const modal = document.getElementById('projectModal');
      
      // Add closing animation
      const modalElement = modal.querySelector('.modal');
      modalElement.style.transform = 'scale(0.7) translateY(50px) rotateX(-15deg)';
      
      setTimeout(() => {
        modal.classList.remove('active');
        document.body.style.overflow = 'auto';
        modalElement.style.transform = '';
        
        // Reset tab visibility for next modal open
        const videosTab = document.querySelector('button[onclick="switchTab(\'videos\')"]');
        const codeTab = document.querySelector('button[onclick="switchTab(\'code\')"]');
        const sourceCodeLink = document.getElementById('sourceCodeLink');
        
        if (videosTab) videosTab.style.display = 'block';
        if (codeTab) codeTab.style.display = 'block';
        if (sourceCodeLink) sourceCodeLink.style.display = 'flex';
      }, 200);
    }

    function switchTab(tabName) {
      // Hide all tab contents with fade out
      const tabContents = document.querySelectorAll('.tab-content');
      tabContents.forEach(content => {
        content.style.animation = 'fadeOut 0.2s ease-out';
        setTimeout(() => {
          content.classList.remove('active');
        }, 200);
      });
      
      // Remove active class from all tabs
      const tabs = document.querySelectorAll('.modal-tab');
      tabs.forEach(tab => tab.classList.remove('active'));
      
      // Show selected tab content with delay for smooth transition
      setTimeout(() => {
        const selectedTab = document.getElementById(tabName + 'Tab');
        if (selectedTab) {
          selectedTab.classList.add('active');
          selectedTab.style.animation = 'fadeInUp 0.5s ease-out';
        }
      }, 200);
      
      // Add active class to clicked tab
      const clickedTab = event?.target;
      if (clickedTab) {
        clickedTab.classList.add('active');
      } else {
        // If called programmatically, find the tab by onclick attribute
        tabs.forEach(tab => {
          if (tab.getAttribute('onclick')?.includes(tabName)) {
            tab.classList.add('active');
          }
        });
      }
    }

    function createModalParticles() {
      const modal = document.querySelector('.modal');
      const particleCount = 15;
      
      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.style.cssText = `
          position: absolute;
          width: 4px;
          height: 4px;
          background: var(--primary);
          border-radius: 50%;
          pointer-events: none;
          animation: particleFloat 3s ease-in-out infinite;
          animation-delay: ${Math.random() * 3}s;
          left: ${Math.random() * 100}%;
          top: ${Math.random() * 100}%;
          box-shadow: 0 0 10px var(--primary);
        `;
        
        modal.appendChild(particle);
        
        // Remove particle after animation
        setTimeout(() => {
          if (particle.parentNode) {
            particle.parentNode.removeChild(particle);
          }
        }, 6000);
      }
    }

    function populateImageGallery(images) {
      const gallery = document.getElementById('imageGallery');
      gallery.innerHTML = images.map(image => `
        <img src="${image}" alt="Project Image" class="gallery-image" onclick="openImagePreview('${image}')">
      `).join('');
    }

    function populateVideoContent(videoHtml) {
      const videoContainer = document.getElementById('videoContainer');
      
      if (videoHtml && videoHtml.trim() !== '') {
        videoContainer.innerHTML = videoHtml;
        
        // Add fullscreen button if there's an iframe
        if (videoHtml.includes('<iframe')) {
          const fullscreenBtn = document.createElement('button');
          fullscreenBtn.className = 'video-fullscreen-btn';
          fullscreenBtn.innerHTML = '⛶ Fullscreen';
          fullscreenBtn.onclick = toggleVideoFullscreen;
          videoContainer.appendChild(fullscreenBtn);
        }
      } else {
        // Default placeholder content
        videoContainer.innerHTML = `
          <div class="video-placeholder">
            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polygon points="5,3 19,12 5,21"></polygon>
            </svg>
            <p>Project demo video will be available soon</p>
          </div>
        `;
      }
    }

    function toggleVideoFullscreen() {
      const videoContainer = document.getElementById('videoContainer');
      const fullscreenBtn = videoContainer.querySelector('.video-fullscreen-btn');
      
      if (!videoContainer.classList.contains('video-fullscreen')) {
        // Enter fullscreen
        videoContainer.classList.add('video-fullscreen');
        fullscreenBtn.innerHTML = '✕ Exit Fullscreen';
        document.body.style.overflow = 'hidden';
        
        // Add escape key listener and click outside listener
        document.addEventListener('keydown', handleFullscreenEscape);
        document.addEventListener('click', handleFullscreenClickOutside);
      } else {
        // Exit fullscreen
        exitVideoFullscreen();
      }
    }

    function exitVideoFullscreen() {
      const videoContainer = document.getElementById('videoContainer');
      const fullscreenBtn = videoContainer.querySelector('.video-fullscreen-btn');
      
      videoContainer.classList.remove('video-fullscreen');
      if (fullscreenBtn) {
        fullscreenBtn.innerHTML = '⛶ Fullscreen';
      }
      document.body.style.overflow = '';
      document.removeEventListener('keydown', handleFullscreenEscape);
      document.removeEventListener('click', handleFullscreenClickOutside);
    }

    function handleFullscreenEscape(e) {
      if (e.key === 'Escape') {
        exitVideoFullscreen();
      }
    }

    function handleFullscreenClickOutside(e) {
      const videoContainer = document.getElementById('videoContainer');
      if (e.target === videoContainer && videoContainer.classList.contains('video-fullscreen')) {
        exitVideoFullscreen();
      }
    }

    function populateCodeBlocks(codeBlocks) {
      const container = document.getElementById('codeBlocks');
      const isMobile = window.innerWidth <= 768;
      
      if (codeBlocks.length === 0) {
        container.innerHTML = `
          <div class="code-block">
            <div style="text-align: center; color: var(--muted-foreground); padding: ${isMobile ? '1.5rem' : '2rem'};">
              <svg width="${isMobile ? '40' : '48'}" height="${isMobile ? '40' : '48'}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-bottom: 1rem;">
                <polyline points="16,18 22,12 16,6"></polyline>
                <polyline points="8,6 2,12 8,18"></polyline>
              </svg>
              <p style="font-size: ${isMobile ? '0.875rem' : '1rem'};">Source code will be available soon</p>
            </div>
          </div>
        `;
        return;
      }
      
      container.innerHTML = codeBlocks.map((block, index) => `
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">${block.language}</span>
            <button class="copy-button" onclick="copyCodeToClipboard(${index})">
              ${isMobile ? 'Copy' : 'Copy Code'}
            </button>
          </div>
          <div class="code-content" id="codeContent${index}">${escapeHtml(block.content)}</div>
          <div style="margin-top: 1rem; padding: 0 ${isMobile ? '1.25rem' : '1.5rem'} ${isMobile ? '1.25rem' : '1.5rem'}; font-size: ${isMobile ? '0.8rem' : '0.875rem'}; color: var(--muted-foreground); font-weight: 500;">
            📁 ${block.title}
          </div>
        </div>
      `).join('');
    }

    function copyCodeToClipboard(index) {
      const codeContent = document.getElementById(`codeContent${index}`);
      const text = codeContent.textContent;
      
      navigator.clipboard.writeText(text).then(() => {
        // Show feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = 'Copied!';
        setTimeout(() => {
          button.textContent = originalText;
        }, 2000);
      }).catch(err => {
        console.error('Failed to copy: ', err);
      });
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function openImagePreview(imageSrc) {
      // Create image preview overlay
      const overlay = document.createElement('div');
      overlay.className = 'image-preview-overlay';
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0);
        backdrop-filter: blur(0px);
        z-index: 2000;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.4s ease;
        padding: 1rem;
      `;
      
      const img = document.createElement('img');
      img.className = 'image-preview-img';
      img.src = imageSrc;
      img.style.cssText = `
        max-width: 90vw;
        max-height: 90vh;
        object-fit: contain;
        border-radius: 1rem;
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
        transform: scale(0.5) rotateY(20deg);
        transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        border: 2px solid hsla(188, 95%, 50%, 0.3);
      `;
      
      // Close button
      const closeBtn = document.createElement('button');
      closeBtn.className = 'image-preview-close';
      closeBtn.innerHTML = '×';
      closeBtn.style.cssText = `
        position: absolute;
        top: 2rem;
        right: 2rem;
        background: hsla(220, 25%, 15%, 0.9);
        border: 2px solid var(--primary);
        color: var(--foreground);
        width: 50px;
        height: 50px;
        border-radius: 50%;
        font-size: 24px;
        cursor: pointer;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
        z-index: 2001;
        display: flex;
        align-items: center;
        justify-content: center;
      `;
      
      // Mobile-specific adjustments
      if (window.innerWidth <= 768) {
        overlay.style.padding = '0.5rem';
        img.style.maxWidth = '95vw';
        img.style.maxHeight = '85vh';
        img.style.borderRadius = '0.75rem';
        closeBtn.style.top = '1rem';
        closeBtn.style.right = '1rem';
        closeBtn.style.width = '44px';
        closeBtn.style.height = '44px';
        closeBtn.style.fontSize = '20px';
      }
      
      overlay.appendChild(img);
      overlay.appendChild(closeBtn);
      document.body.appendChild(overlay);
      
      // Animate in
      requestAnimationFrame(() => {
        overlay.style.background = 'rgba(0, 0, 0, 0.9)';
        overlay.style.backdropFilter = 'blur(15px)';
        img.style.transform = 'scale(1) rotateY(0deg)';
      });
      
      // Close handlers
      const closePreview = () => {
        overlay.style.background = 'rgba(0, 0, 0, 0)';
        overlay.style.backdropFilter = 'blur(0px)';
        img.style.transform = 'scale(0.5) rotateY(-20deg)';
        
        setTimeout(() => {
          if (document.body.contains(overlay)) {
            document.body.removeChild(overlay);
          }
        }, 400);
      };
      
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) closePreview();
      });
      closeBtn.addEventListener('click', closePreview);
      
      // Close with Escape key
      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          closePreview();
          document.removeEventListener('keydown', handleEscape);
        }
      };
      document.addEventListener('keydown', handleEscape);
    }

    // Close modal when clicking outside
    document.getElementById('projectModal').addEventListener('click', (e) => {
      if (e.target.classList.contains('modal-overlay')) {
        closeProjectModal();
      }
    });

    // Close modal with Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeProjectModal();
      }
    });

    // Form submission
    function handleFormSubmit(event) {
      event.preventDefault();

      // Get form data
      const name = document.getElementById('name').value;
      const email = document.getElementById('email').value;
      const message = document.getElementById('message').value;

      // Simple form validation and feedback
      if (name && email && message) {
        alert('Message sent successfully! I\'ll get back to you soon.');

        // Reset form
        document.getElementById('name').value = '';
        document.getElementById('email').value = '';
        document.getElementById('message').value = '';
      }
    }

    // Mario-style Platform Game Animation
    function initPlatformGame() {
      const canvas = document.getElementById('platformGame');
      const ctx = canvas.getContext('2d');

      let worldInitialized = false;

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        // Use exact viewport height so the canvas matches visible area on mobile
        canvas.height = window.innerHeight;

        // If the world has already been initialized, re-create game world so positions match the new size
        if (worldInitialized) {
          initGameWorld();
        }
      }
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      // Game entities
  let platforms = [];
  let coins = [];
  let enemies = [];
  let powerUps = [];
  let particles = [];
  let mario = null;
  let animatedClouds = []; // Add animated clouds array
  let snowflakes = []; // Add snow array
  let backgroundCloudsSmall = [];
  let backgroundCloudsMid = [];
  let backgroundCloudsLarge = [];

      // Colors and themes - Updated for blue ninja character
      const colors = {
        mario: '#FF6B35',
        ground: '#8B4513',
        platform: '#228B22', // Green platforms like in the image
        platformDark: '#1F6B1F', // Darker green for shading
        platformLight: '#32CD32', // Lighter green for highlights
        coin: '#FFD700',
        enemy: '#FFFFFF', // White ghost-like enemies
        enemyGlow: '#E6E6FA',
        powerUp: '#FFD700',
        sky: '#4A90E2', // Deeper blue sky
        skyLight: '#6BB6FF',
        cloud: '#FFFFFF',
        cloudShadow: '#E6E6FA',
        brick: '#8B4513',
        tree: '#228B22',
        treeTrunk: '#8B4513',
        ladder: '#CD853F',
        // Blue ninja character colors
        ninjaBody: '#2E5C8A', // Dark blue body
        ninjaBodyLight: '#4A90E2', // Light blue highlights
        ninjaBodyDark: '#1E3A5F', // Darker blue shadows
        ninjaMask: '#87CEEB', // Light blue mask/face
        ninjaEyes: '#FFFFFF', // White eyes
        ninjaEyePupils: '#000000', // Black pupils
        ninjaOutline: '#0F1419' // Very dark outline
      };

      // Mario character
      class Mario {
        constructor() {
          this.x = 150;
          this.y = canvas.height - 80;
          this.width = 48; // More moderate size increase
          this.height = 48; // More moderate size increase
          this.vx = 2.5; 
          this.vy = 0;
          this.gravity = 0.6; 
          this.jumpPower = -15; 
          this.onGround = false;
          this.direction = 1;
          this.animFrame = 0;
          this.animSpeed = 0.2;
          this.jumpCooldown = 0;
        }

        update() {
          // Horizontal movement
          this.x += this.vx * this.direction;
          
          // Wrap around screen
          if (this.x > canvas.width + this.width) {
            this.x = -this.width;
          } else if (this.x < -this.width) {
            this.x = canvas.width;
          }

          // Gravity and jumping
          this.vy += this.gravity;
          this.y += this.vy;

          // Platform collision
          this.onGround = false;
          platforms.forEach(platform => {
            if (this.x < platform.x + platform.width &&
                this.x + this.width > platform.x &&
                this.y + this.height > platform.y &&
                this.y + this.height < platform.y + platform.height + 10 &&
                this.vy >= 0) {
              this.y = platform.y - this.height;
              this.vy = 0;
              this.onGround = true;
            }
          });

          // Ground collision - Updated for moderate platform
          if (this.y + this.height > canvas.height - 30) { 
            this.y = canvas.height - 30 - this.height;
            this.vy = 0;
            this.onGround = true;
          }

          // Random jumping
          this.jumpCooldown--;
          if (this.onGround && this.jumpCooldown <= 0 && Math.random() < 0.005) {
            this.vy = this.jumpPower;
            this.jumpCooldown = 60;
            createJumpParticles(this.x + this.width/2, this.y + this.height);
          }

          // Change direction occasionally
          if (Math.random() < 0.002) {
            this.direction *= -1;
          }

          // Animation
          this.animFrame += this.animSpeed;
          if (this.animFrame >= 3) this.animFrame = 0;
        }

        draw() {
          ctx.save();
          
          // Flip sprite based on direction
          if (this.direction < 0) {
            ctx.scale(-1, 1);
            ctx.translate(-this.x - this.width, 0);
          } else {
            ctx.translate(this.x, 0);
          }

          // Draw Growtopia-style character (blocky, pixelated)
          const frame = Math.floor(this.animFrame);
          const y = this.y;
          const centerX = this.width / 2;
          
          // === HEAD (square/rectangular like Growtopia) ===
          ctx.fillStyle = colors.ninjaMask; // Light blue head/face
          ctx.fillRect(centerX - 10, y + 4, 20, 16); // Square head
          
          // Head outline
          ctx.strokeStyle = colors.ninjaOutline;
          ctx.lineWidth = 1;
          ctx.strokeRect(centerX - 10, y + 4, 20, 16);
          
          // === HAIR/HAT (Growtopia characters often have distinctive hair) ===
          ctx.fillStyle = colors.ninjaBody; // Dark blue hair/hat
          ctx.fillRect(centerX - 10, y + 4, 20, 8); // Top portion as hair/hat
          ctx.strokeRect(centerX - 10, y + 4, 20, 8);
          
          // Hair spikes/details
          ctx.fillRect(centerX - 8, y + 2, 4, 4); // Left hair spike
          ctx.strokeRect(centerX - 8, y + 2, 4, 4);
          ctx.fillRect(centerX - 2, y + 1, 4, 5); // Center hair spike
          ctx.strokeRect(centerX - 2, y + 1, 4, 5);
          ctx.fillRect(centerX + 4, y + 2, 4, 4); // Right hair spike
          ctx.strokeRect(centerX + 4, y + 2, 4, 4);
          
          // === BODY (rectangular, Growtopia style) ===
          ctx.fillStyle = colors.ninjaBody; // Dark blue shirt/body
          ctx.fillRect(centerX - 8, y + 20, 16, 16); // Square body
          ctx.strokeRect(centerX - 8, y + 20, 16, 16);
          
          // Shirt details (Growtopia characters have simple clothing)
          ctx.fillStyle = colors.ninjaBodyLight; // Light blue for shirt details
          ctx.fillRect(centerX - 6, y + 22, 12, 4); // Chest area
          ctx.strokeRect(centerX - 6, y + 22, 12, 4);
          
          // Belt/waist
          ctx.fillStyle = colors.ninjaBodyDark;
          ctx.fillRect(centerX - 8, y + 30, 16, 2);
          ctx.strokeRect(centerX - 8, y + 30, 16, 2);
          
          // === ARMS (blocky, Growtopia style) ===
          ctx.fillStyle = colors.ninjaMask; // Same as face color
          
          if (this.onGround && Math.abs(this.vx) > 0) {
            // Walking arms animation (simple up/down)
            const armOffset = frame % 2 === 0 ? 2 : -2;
            // Left arm
            ctx.fillRect(centerX - 12, y + 22 + armOffset, 4, 10);
            ctx.strokeRect(centerX - 12, y + 22 + armOffset, 4, 10);
            // Right arm
            ctx.fillRect(centerX + 8, y + 22 - armOffset, 4, 10);
            ctx.strokeRect(centerX + 8, y + 22 - armOffset, 4, 10);
          } else {
            // Standing arms
            ctx.fillRect(centerX - 12, y + 24, 4, 10);
            ctx.strokeRect(centerX - 12, y + 24, 4, 10);
            ctx.fillRect(centerX + 8, y + 24, 4, 10);
            ctx.strokeRect(centerX + 8, y + 24, 4, 10);
          }
          
          // === LEGS (blocky, animated) ===
          ctx.fillStyle = colors.ninjaBody; // Dark blue pants
          
          if (this.onGround && Math.abs(this.vx) > 0) {
            // Walking legs animation
            const legOffset = frame % 2 === 0 ? 2 : -2;
            // Left leg
            ctx.fillRect(centerX - 6 + legOffset, y + 36, 4, 12);
            ctx.strokeRect(centerX - 6 + legOffset, y + 36, 4, 12);
            // Right leg
            ctx.fillRect(centerX + 2 - legOffset, y + 36, 4, 12);
            ctx.strokeRect(centerX + 2 - legOffset, y + 36, 4, 12);
          } else {
            // Standing legs
            ctx.fillRect(centerX - 4, y + 36, 4, 12);
            ctx.strokeRect(centerX - 4, y + 36, 4, 12);
            ctx.fillRect(centerX, y + 36, 4, 12);
            ctx.strokeRect(centerX, y + 36, 4, 12);
          }
          
          // === FEET (simple blocks) ===
          ctx.fillStyle = colors.ninjaBodyDark; // Dark shoes
          if (this.onGround && Math.abs(this.vx) > 0) {
            const legOffset = frame % 2 === 0 ? 2 : -2;
            ctx.fillRect(centerX - 6 + legOffset, y + 46, 6, 3);
            ctx.strokeRect(centerX - 6 + legOffset, y + 46, 6, 3);
            ctx.fillRect(centerX + 2 - legOffset, y + 46, 6, 3);
            ctx.strokeRect(centerX + 2 - legOffset, y + 46, 6, 3);
          } else {
            ctx.fillRect(centerX - 4, y + 46, 6, 3);
            ctx.strokeRect(centerX - 4, y + 46, 6, 3);
            ctx.fillRect(centerX, y + 46, 6, 3);
            ctx.strokeRect(centerX, y + 46, 6, 3);
          }
          
          // === EYES (Growtopia style - simple black rectangles) ===
          ctx.fillStyle = colors.ninjaEyePupils; // Black
          ctx.fillRect(centerX - 6, y + 13, 3, 3); // Left eye
          ctx.fillRect(centerX + 3, y + 13, 3, 3); // Right eye
          
          // Eye highlights (small white pixels)
          ctx.fillStyle = colors.ninjaEyes; // White
          ctx.fillRect(centerX - 5, y + 13, 1, 1); // Left eye highlight
          ctx.fillRect(centerX + 4, y + 13, 1, 1); // Right eye highlight
          
          // === MOUTH (simple Growtopia style) ===
          ctx.fillStyle = colors.ninjaEyePupils; // Black
          ctx.fillRect(centerX - 1, y + 17, 2, 1); // Simple mouth line

          ctx.restore();
        }
      }

      // Platform class
      class Platform {
        constructor(x, y, width, height, type = 'normal') {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
          this.type = type;
          this.animOffset = Math.random() * Math.PI * 2;
        }

        draw() {
          ctx.save();
          
            // Compute floating offset without mutating this.y to avoid cumulative drift
            let floatOffset = 0;
            if (this.type === 'floating') {
              // Floating platform animation (visual only)
              floatOffset = Math.sin(Date.now() * 0.002 + this.animOffset) * 5;
              // We'll translate the drawing context by this offset below instead of changing this.y
              ctx.translate(0, floatOffset * 0.1);
            }

          // Draw platform based on type
          switch (this.type) {
            case 'brick':
              this.drawBrickPlatform();
              break;
            case 'pipe':
              this.drawPipe();
              break;
            case 'cloud':
              this.drawCloudPlatform();
              break;
            default:
              this.drawNormalPlatform();
          }
          
          // Restore context; any translate applied earlier is reverted here
          ctx.restore();
        }

        drawNormalPlatform() {
          // Draw pixel-perfect platform like in the image - Moderate scale
          const pixelSize = 6; // Moderate pixel size increase
          
          // Main platform body (green)
          ctx.fillStyle = colors.platform;
          ctx.fillRect(this.x, this.y, this.width, this.height);
          
          // Top grass texture
          ctx.fillStyle = colors.platformLight;
          for (let x = 0; x < this.width; x += pixelSize * 2) {
            // Small grass blades on top
            ctx.fillRect(this.x + x, this.y - 3, pixelSize, 3);
            ctx.fillRect(this.x + x + pixelSize, this.y - 1, pixelSize, 1);
          }
          
          // Bottom shadow/dirt
          ctx.fillStyle = colors.platformDark;
          ctx.fillRect(this.x, this.y + this.height - 6, this.width, 6);
          
          // Side highlights and shadows for 3D effect
          ctx.fillStyle = colors.platformLight;
          ctx.fillRect(this.x, this.y, 3, this.height);
          
          ctx.fillStyle = colors.platformDark;
          ctx.fillRect(this.x + this.width - 3, this.y, 3, this.height);
        }

        drawBrickPlatform() {
          // Draw brown brick platforms with proper containment
          ctx.fillStyle = colors.brick;
          ctx.fillRect(this.x, this.y, this.width, this.height);
          
          // Brick pattern - contained within platform boundaries
          const brickWidth = 24; // Moderate brick size
          const brickHeight = 12; // Moderate brick size
          
          ctx.fillStyle = '#A0522D'; // Lighter brown for highlights
          for (let y = 0; y < this.height; y += brickHeight) {
            for (let x = 0; x < this.width; x += brickWidth) {
              // Offset every other row
              const offsetX = (y / brickHeight) % 2 === 0 ? 0 : brickWidth / 2;
              const brickX = this.x + x + offsetX;
              
              // Only draw if brick is within platform bounds
              if (brickX >= this.x && brickX + brickWidth <= this.x + this.width) {
                // Brick highlight
                ctx.fillRect(brickX, this.y + y, brickWidth - 1, 1);
                ctx.fillRect(brickX, this.y + y, 1, brickHeight - 1);
              }
            }
          }
          
          // Dark outlines - also contained within bounds
          ctx.fillStyle = '#654321';
          for (let y = 0; y < this.height; y += brickHeight) {
            for (let x = 0; x < this.width; x += brickWidth) {
              const offsetX = (y / brickHeight) % 2 === 0 ? 0 : brickWidth / 2;
              const brickX = this.x + x + offsetX;
              
              // Only draw if brick is within platform bounds
              if (brickX >= this.x && brickX + brickWidth <= this.x + this.width) {
                // Brick outline
                ctx.fillRect(brickX + brickWidth - 1, this.y + y, 1, brickHeight);
                ctx.fillRect(brickX, this.y + y + brickHeight - 1, brickWidth, 1);
              }
            }
          }
        }

        drawPipe() {
          // Draw ladder instead of pipe to match the image - Moderate scale
          const ladderWidth = 24; // Moderate ladder width
          const ladderHeight = this.height;
          const centerX = this.x + (this.width - ladderWidth) / 2;
          
          // Ladder sides
          ctx.fillStyle = colors.ladder;
          ctx.fillRect(centerX, this.y, 4, ladderHeight); 
          ctx.fillRect(centerX + ladderWidth - 4, this.y, 4, ladderHeight);
          
          // Ladder rungs
          const rungSpacing = 18; // Moderate spacing
          for (let y = 0; y < ladderHeight; y += rungSpacing) {
            ctx.fillRect(centerX, this.y + y, ladderWidth, 4); 
          }
          
          // Highlight for 3D effect
          ctx.fillStyle = '#DEB887';
          ctx.fillRect(centerX, this.y, 1, ladderHeight); 
          ctx.fillRect(centerX + ladderWidth - 4, this.y, 1, ladderHeight);
          
          for (let y = 0; y < ladderHeight; y += rungSpacing) {
            ctx.fillRect(centerX, this.y + y, ladderWidth, 1); 
          }
        }

        drawCloudPlatform() {
          // White cloud platform with pixel art style
          ctx.fillStyle = colors.cloud;
          
          // Main cloud body
          ctx.fillRect(this.x + 8, this.y + 4, this.width - 16, this.height - 8);
          
          // Cloud bumps (pixel art style)
          const bumpSize = 8;
          for (let x = 0; x < this.width - bumpSize; x += bumpSize) {
            // Top bumps
            if (x + bumpSize <= this.width - 8) {
              ctx.fillRect(this.x + x + 4, this.y, bumpSize, 8);
            }
            // Bottom bumps
            if (x + bumpSize <= this.width - 8) {
              ctx.fillRect(this.x + x + 4, this.y + this.height - 4, bumpSize, 4);
            }
          }
          
          // Cloud side curves
          ctx.fillRect(this.x + 4, this.y + 8, 8, this.height - 12);
          ctx.fillRect(this.x + this.width - 12, this.y + 8, 8, this.height - 12);
          
          // Shadow for depth
          ctx.fillStyle = colors.cloudShadow;
          ctx.fillRect(this.x + this.width - 8, this.y + 4, 4, this.height - 8);
          ctx.fillRect(this.x + 8, this.y + this.height - 4, this.width - 16, 2);
        }
      }

      // Coin class
      class Coin {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.size = 18; // Moderate coin size increase
          this.rotation = 0;
          this.rotationSpeed = 0.1;
          this.floatOffset = Math.random() * Math.PI * 2;
          this.collected = false;
        }

        update() {
          this.rotation += this.rotationSpeed;
          
          // Floating animation
          this.y += Math.sin(Date.now() * 0.003 + this.floatOffset) * 0.5;
          
          // Check collision with Mario
          if (mario && !this.collected &&
              mario.x < this.x + this.size &&
              mario.x + mario.width > this.x &&
              mario.y < this.y + this.size &&
              mario.y + mario.height > this.y) {
            this.collected = true;
            createCoinParticles(this.x + this.size/2, this.y + this.size/2);
          }
        }

        draw() {
          if (this.collected) return;
          
          ctx.save();
          ctx.translate(this.x + this.size/2, this.y + this.size/2);
          ctx.rotate(this.rotation);
          
          // Coin body
          ctx.fillStyle = colors.coin;
          ctx.beginPath();
          ctx.arc(0, 0, this.size/2, 0, Math.PI * 2);
          ctx.fill();
          
          // Coin highlight
          ctx.fillStyle = '#FFFFE0';
          ctx.beginPath();
          ctx.arc(-2, -2, this.size/4, 0, Math.PI * 2);
          ctx.fill();
          
          // Coin center
          ctx.fillStyle = colors.coin;
          ctx.font = 'bold 10px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('¢', 0, 3);
          
          ctx.restore();
        }
      }

      // Enemy class (Goomba-style)
      class Enemy {
        constructor(x, y, direction = -1) {
          this.x = x;
          this.y = y;
          this.width = 36; // Moderate size increase
          this.height = 36; // Moderate size increase
          this.vx = 1.2 * direction; // Allow different directions
          this.direction = direction;
          this.animFrame = 0;
          this.animSpeed = 0.1;
        }

        update() {
          this.x += this.vx;
          
          // Bounce off screen edges
          if (this.x <= 0 || this.x + this.width >= canvas.width) {
            this.vx *= -1;
            this.direction *= -1;
          }
          
          // Animation
          this.animFrame += this.animSpeed;
          if (this.animFrame >= 2) this.animFrame = 0;
          
          // Platform collision
          let onPlatform = false;
          platforms.forEach(platform => {
            if (this.x < platform.x + platform.width &&
                this.x + this.width > platform.x &&
                this.y + this.height >= platform.y &&
                this.y + this.height <= platform.y + 10) {
              onPlatform = true;
            }
          });
          
          // Fall if not on platform - Updated for scaled ground
          if (!onPlatform && this.y + this.height < canvas.height - 40) {
            this.y += 2;
          }
        }

        draw() {
          ctx.save();
          
          // Ghost body (white like in the image) - Moderate scale
          ctx.fillStyle = colors.enemy;
          
          // Main ghost body (rounded top, wavy bottom)
          ctx.beginPath();
          ctx.arc(this.x + this.width/2, this.y + 12, 15, Math.PI, 0, false);
          ctx.lineTo(this.x + this.width - 3, this.y + this.height - 6);
          
          // Wavy bottom edge
          for (let i = 0; i < 3; i++) {
            const waveX = this.x + this.width - 3 - (i * 9);
            ctx.lineTo(waveX, this.y + this.height);
            ctx.lineTo(waveX - 4, this.y + this.height - 6);
          }
          
          ctx.lineTo(this.x + 3, this.y + this.height - 6);
          ctx.closePath();
          ctx.fill();
          
          // Ghost glow effect
          ctx.fillStyle = colors.enemyGlow;
          ctx.beginPath();
          ctx.arc(this.x + this.width/2, this.y + 12, 12, Math.PI, 0, false);
          ctx.lineTo(this.x + this.width - 6, this.y + this.height - 9);
          ctx.lineTo(this.x + 6, this.y + this.height - 9);
          ctx.closePath();
          ctx.fill();
          
          // Eyes (simple black dots)
          ctx.fillStyle = '#000000';
          const eyeOffset = Math.floor(this.animFrame) === 0 ? 0 : 1;
          ctx.fillRect(this.x + 9 + eyeOffset, this.y + 9, 3, 3);
          ctx.fillRect(this.x + 24 + eyeOffset, this.y + 9, 3, 3);
          
          // Simple mouth
          ctx.fillRect(this.x + 15, this.y + 18, 6, 1);
          
          ctx.restore();
        }
      }

      // Animated Cloud class
      class AnimatedCloud {
        constructor(x, y, scale, speed) {
          this.x = x;
          this.y = y;
          this.scale = scale;
          this.speed = speed;
          this.alpha = 0.3 + Math.random() * 0.4;
        }

        update() {
          this.x += this.speed;
          
          // Reset position when cloud goes off screen
          if (this.x > canvas.width + 100) {
            this.x = -100;
            this.y = 20 + Math.random() * 120; // Random height
          }
        }

        draw() {
          const fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
          drawPixelCloud(this.x, this.y, this.scale, fillStyle);
        }
      }

      // Snow class for winter atmosphere
      class Snow {
        constructor() {
          this.x = Math.random() * canvas.width;
          this.y = -10;
          this.size = Math.random() * 3 + 1; // 1-4px snowflakes
          this.speed = Math.random() * 1 + 0.5; // 0.5-1.5 fall speed
          this.drift = Math.random() * 0.5 - 0.25; // -0.25 to 0.25 horizontal drift
          this.opacity = Math.random() * 0.7 + 0.3; // 0.3-1.0 opacity
        }

        update() {
          this.y += this.speed;
          this.x += this.drift;
          
          // Reset when off screen
          if (this.y > canvas.height + 10) {
            this.y = -10;
            this.x = Math.random() * canvas.width;
          }
          
          // Wrap horizontally
          if (this.x > canvas.width + 10) {
            this.x = -10;
          } else if (this.x < -10) {
            this.x = canvas.width + 10;
          }
        }

        draw() {
          ctx.save();
          ctx.globalAlpha = this.opacity;
          ctx.fillStyle = '#FFFFFF';
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }

      // Particle system
      class Particle {
        constructor(x, y, vx, vy, color, life) {
          this.x = x;
          this.y = y;
          this.vx = vx;
          this.vy = vy;
          this.color = color;
          this.life = life;
          this.maxLife = life;
          this.size = Math.random() * 4 + 2;
        }

        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.vy += 0.2; // gravity
          this.life--;
        }

        draw() {
          const alpha = this.life / this.maxLife;
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }

      // Particle creation functions
      function createJumpParticles(x, y) {
        for (let i = 0; i < 8; i++) {
          const vx = (Math.random() - 0.5) * 6;
          const vy = Math.random() * -3 - 2;
          particles.push(new Particle(x, y, vx, vy, '#DDDDDD', 30));
        }
      }

      function createCoinParticles(x, y) {
        for (let i = 0; i < 12; i++) {
          const vx = (Math.random() - 0.5) * 8;
          const vy = Math.random() * -6 - 2;
          particles.push(new Particle(x, y, vx, vy, colors.coin, 40));
        }
      }

      // Initialize game world
      function initGameWorld() {
        // Create Mario
        mario = new Mario();

        // Create platforms
        platforms = [
          // Ground platforms - Moderate thickness
          new Platform(0, canvas.height - 30, canvas.width, 30, 'normal'),
          
          // Lower level platforms - Better distributed + more on right
          new Platform(150, canvas.height - 120, 100, 30, 'normal'),
          new Platform(350, canvas.height - 140, 80, 30, 'brick'),
          new Platform(550, canvas.height - 100, 100, 30, 'cloud'),
          new Platform(750, canvas.height - 160, 100, 30, 'normal'),
          new Platform(950, canvas.height - 110, 80, 30, 'brick'),
          new Platform(1150, canvas.height - 130, 120, 30, 'normal'),
          new Platform(1350, canvas.height - 140, 100, 30, 'cloud'),
          new Platform(1550, canvas.height - 120, 80, 30, 'brick'),
          
          // Mid level platforms - More spread out + extended right
          new Platform(100, canvas.height - 220, 80, 30, 'cloud'),
          new Platform(280, canvas.height - 260, 100, 30, 'normal'),
          new Platform(480, canvas.height - 240, 80, 30, 'brick'),
          new Platform(680, canvas.height - 220, 120, 30, 'normal'),
          new Platform(900, canvas.height - 280, 80, 30, 'cloud'),
          new Platform(1100, canvas.height - 240, 100, 30, 'normal'),
          new Platform(1300, canvas.height - 260, 80, 30, 'brick'),
          new Platform(1500, canvas.height - 220, 120, 30, 'normal'),
          
          // Higher platforms - Evenly spaced + extended right
          new Platform(200, canvas.height - 340, 80, 30, 'normal'),
          new Platform(400, canvas.height - 380, 100, 30, 'cloud'),
          new Platform(600, canvas.height - 360, 80, 30, 'brick'),
          new Platform(800, canvas.height - 400, 100, 30, 'normal'),
          new Platform(1000, canvas.height - 360, 120, 30, 'cloud'),
          new Platform(1200, canvas.height - 380, 80, 30, 'normal'),
          new Platform(1400, canvas.height - 340, 100, 30, 'brick'),
          new Platform(1600, canvas.height - 360, 80, 30, 'cloud'),
          
          // Ladders connecting platforms - Anchored to platform tops to prevent floating
          new Platform(320, canvas.height - 260, 24, 140, 'pipe'), // Anchored to mid platform at y-260
          new Platform(620, canvas.height - 360, 24, 120, 'pipe'), // Anchored to high platform at y-360  
          new Platform(940, canvas.height - 280, 24, 160, 'pipe'), // Anchored to mid platform at y-280
          new Platform(1240, canvas.height - 380, 24, 140, 'pipe'), // Anchored to high platform at y-380
          new Platform(1440, canvas.height - 340, 24, 120, 'pipe'), // Anchored to high platform at y-340
          new Platform(1640, canvas.height - 360, 24, 140, 'pipe'), // Anchored to high platform at y-360
        ];

        // Create coins - Better distributed across screen + extended right
        coins = [
          // Lower level coins - Spread evenly + more on right
          new Coin(180, canvas.height - 150),
          new Coin(380, canvas.height - 170),
          new Coin(580, canvas.height - 130),
          new Coin(780, canvas.height - 190),
          new Coin(980, canvas.height - 140),
          new Coin(1180, canvas.height - 160),
          new Coin(1380, canvas.height - 170),
          new Coin(1580, canvas.height - 150),
          
          // Mid level coins - Better spacing + extended right
          new Coin(130, canvas.height - 250),
          new Coin(330, canvas.height - 290),
          new Coin(530, canvas.height - 270),
          new Coin(730, canvas.height - 250),
          new Coin(930, canvas.height - 310),
          new Coin(1130, canvas.height - 270),
          new Coin(1330, canvas.height - 290),
          new Coin(1530, canvas.height - 250),
          
          // High level coins - Evenly distributed + extended right
          new Coin(230, canvas.height - 370),
          new Coin(430, canvas.height - 410),
          new Coin(630, canvas.height - 390),
          new Coin(830, canvas.height - 430),
          new Coin(1030, canvas.height - 390),
          new Coin(1230, canvas.height - 410),
          new Coin(1430, canvas.height - 370),
          new Coin(1630, canvas.height - 390),
          
          // Floating coins in gaps + more on right
          new Coin(80, canvas.height - 180),
          new Coin(480, canvas.height - 320),
          new Coin(880, canvas.height - 200),
          new Coin(1280, canvas.height - 300),
          new Coin(1480, canvas.height - 280),
          new Coin(1680, canvas.height - 320),
        ];

        // Create enemies (white ghosts) - Reduced number for cleaner look
        enemies = [
          // Ground level enemies - fewer but well distributed
          new Enemy(400, canvas.height - 60, -1),  // Moving left
          new Enemy(900, canvas.height - 60, 1),   // Moving right
          new Enemy(1400, canvas.height - 60, -1), // Moving left
          
          // Lower platform enemies - reduced
          new Enemy(300, canvas.height - 150, 1),
          new Enemy(800, canvas.height - 140, -1),
          new Enemy(1300, canvas.height - 170, 1),
          
          // Mid platform enemies - fewer
          new Enemy(200, canvas.height - 250, -1),
          new Enemy(700, canvas.height - 270, 1),
          new Enemy(1200, canvas.height - 290, -1),
          
          // High platform enemies - minimal
          new Enemy(500, canvas.height - 410, 1),
          new Enemy(1000, canvas.height - 430, -1),
        ];

        // Create animated clouds - also bigger and more visible
        animatedClouds = [
          new AnimatedCloud(-50, 80, 1.2, 0.2), // Bigger and lower
          new AnimatedCloud(200, 120, 1.5, 0.15), // Bigger and lower
          new AnimatedCloud(500, 60, 1.3, 0.25), // Bigger and lower
          new AnimatedCloud(800, 140, 1.8, 0.1), // Much bigger and lower
          new AnimatedCloud(1100, 100, 1.1, 0.3), // Bigger and lower
          new AnimatedCloud(1400, 130, 1.4, 0.18), // Bigger and lower
          
          // Additional layer of slower, bigger clouds - even more prominent
          new AnimatedCloud(100, 50, 2.0, 0.08), // Much bigger
          new AnimatedCloud(600, 30, 2.5, 0.06), // Much bigger
          new AnimatedCloud(1200, 70, 2.2, 0.09), // Much bigger
        ];

        // Precompute background cloud layers (stable shapes/positions to avoid per-frame randomness)
        backgroundCloudsSmall = [];
        backgroundCloudsMid = [];
        backgroundCloudsLarge = [];

        // Small background clouds - bigger and lower for visibility
        for (let i = 0; i < 8; i++) {
          backgroundCloudsSmall.push({
            x: Math.random() * (canvas.width + 400) - 200,
            y: 60 + Math.random() * 120, // Lower: was 10-90, now 60-180
            size: 0.8 + Math.random() * 0.6, // Bigger: was 0.3-0.6, now 0.8-1.4
            fillStyle: 'rgba(255, 255, 255, 0.5)' // Slightly more opaque
          });
        }

        // Mid-ground clouds - bigger and lower
        for (let i = 0; i < 6; i++) {
          backgroundCloudsMid.push({
            x: Math.random() * (canvas.width + 400) - 200,
            y: 80 + Math.random() * 140, // Lower: was 30-120, now 80-220
            size: 1.0 + Math.random() * 0.8, // Bigger: was 0.5-1.0, now 1.0-1.8
            fillStyle: 'rgba(255, 255, 255, 0.7)'
          });
        }

        // Foreground larger clouds - bigger and lower
        for (let i = 0; i < 5; i++) {
          backgroundCloudsLarge.push({
            x: Math.random() * (canvas.width + 400) - 200,
            y: 40 + Math.random() * 160, // Lower: was 10-110, now 40-200
            size: 1.4 + Math.random() * 1.0, // Bigger: was 0.8-1.4, now 1.4-2.4
            fillStyle: 'rgba(255, 255, 255, 0.9)'
          });
        }

        // Create snow for winter atmosphere
        snowflakes = [];
        for (let i = 0; i < 100; i++) { // 100 snowflakes
          snowflakes.push(new Snow());
        }

          // Mark world as initialized so future resize events will re-create the world
          worldInitialized = true;
      }

      // Draw background
      function drawBackground() {
        // Sky gradient - deeper blue like in the image
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, colors.skyLight);
        gradient.addColorStop(0.4, colors.sky);
        gradient.addColorStop(1, '#366BB3');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw distant mountains/hills
        drawMountains();
        
        // Draw clouds in background
        drawClouds();
        
        // Draw trees
        drawTrees();
        
        // Draw hills
        drawHills();
      }

      function drawMountains() {
        // Distant mountains in darker blue
        ctx.fillStyle = '#2E5C8A';
        ctx.beginPath();
        ctx.moveTo(0, canvas.height - 200);
        ctx.lineTo(150, canvas.height - 280);
        ctx.lineTo(300, canvas.height - 240);
        ctx.lineTo(450, canvas.height - 300);
        ctx.lineTo(600, canvas.height - 260);
        ctx.lineTo(800, canvas.height - 320);
        ctx.lineTo(1000, canvas.height - 280);
        ctx.lineTo(canvas.width, canvas.height - 250);
        ctx.lineTo(canvas.width, canvas.height);
        ctx.lineTo(0, canvas.height);
        ctx.closePath();
        ctx.fill();
      }

      function drawTrees() {
        // Draw pixel art trees like in the image - Better distributed + extended right
        const treePositions = [
          {x: 80, y: canvas.height - 120, scale: 1},
          {x: 400, y: canvas.height - 100, scale: 0.9},
          {x: 700, y: canvas.height - 110, scale: 1.1},
          {x: 1000, y: canvas.height - 120, scale: 0.8},
          {x: 1300, y: canvas.height - 115, scale: 1.2},
          {x: 1600, y: canvas.height - 105, scale: 1.0},
          {x: 1900, y: canvas.height - 125, scale: 0.9},
        ];

        treePositions.forEach(tree => {
          drawPixelTree(tree.x, tree.y, tree.scale);
        });
      }

      function drawPixelTree(x, y, scale) {
        ctx.save();
        const pixelSize = 4 * scale;
        
        // Tree trunk
        ctx.fillStyle = colors.treeTrunk;
        ctx.fillRect(x - pixelSize, y, pixelSize * 2, pixelSize * 6);
        
        // Tree foliage (round pixel art style)
        ctx.fillStyle = colors.tree;
        
        // Bottom layer of leaves
        ctx.fillRect(x - pixelSize * 3, y - pixelSize * 2, pixelSize * 6, pixelSize * 3);
        
        // Middle layer
        ctx.fillRect(x - pixelSize * 4, y - pixelSize * 5, pixelSize * 8, pixelSize * 3);
        
        // Top layer
        ctx.fillRect(x - pixelSize * 3, y - pixelSize * 8, pixelSize * 6, pixelSize * 3);
        
        // Tree highlights
        ctx.fillStyle = colors.platformLight;
        ctx.fillRect(x - pixelSize * 3, y - pixelSize * 2, pixelSize, pixelSize * 3);
        ctx.fillRect(x - pixelSize * 4, y - pixelSize * 5, pixelSize, pixelSize * 3);
        ctx.fillRect(x - pixelSize * 3, y - pixelSize * 8, pixelSize, pixelSize * 3);
        
        ctx.restore();
      }

      function drawClouds() {
        // Draw precomputed cloud layers to avoid per-frame jitter
        backgroundCloudsSmall.forEach(cloud => {
          if (cloud.x < canvas.width + 200 && cloud.x > -200) drawPixelCloud(cloud.x, cloud.y, cloud.size, cloud.fillStyle);
        });

        backgroundCloudsMid.forEach(cloud => {
          if (cloud.x < canvas.width + 200 && cloud.x > -200) drawPixelCloud(cloud.x, cloud.y, cloud.size, cloud.fillStyle);
        });

        backgroundCloudsLarge.forEach(cloud => {
          if (cloud.x < canvas.width + 200 && cloud.x > -200) drawPixelCloud(cloud.x, cloud.y, cloud.size, cloud.fillStyle);
        });
      }

      function drawPixelCloud(x, y, scale, fillStyle) {
        ctx.save();
        const pixelSize = 6 * scale; // Moderate cloud pixel size
        
        ctx.fillStyle = fillStyle;
        
        // Main cloud body
        ctx.fillRect(x, y + pixelSize, pixelSize * 8, pixelSize * 3);
        
        // Cloud bumps
        ctx.fillRect(x + pixelSize, y, pixelSize * 2, pixelSize * 2);
        ctx.fillRect(x + pixelSize * 3, y, pixelSize * 3, pixelSize * 2);
        ctx.fillRect(x + pixelSize * 6, y, pixelSize * 2, pixelSize * 2);
        
        // Bottom variations
        ctx.fillRect(x + pixelSize, y + pixelSize * 4, pixelSize * 2, pixelSize);
        ctx.fillRect(x + pixelSize * 5, y + pixelSize * 4, pixelSize * 2, pixelSize);
        
        // Add deterministic extra bumps for larger clouds to avoid per-frame jitter
        if (scale > 1.2) {
          ctx.fillRect(x - pixelSize, y + pixelSize * 2, pixelSize, pixelSize);
          ctx.fillRect(x + pixelSize * 8, y + pixelSize * 2, pixelSize, pixelSize);
        }
        
        ctx.restore();
      }

      function drawHills() {
        // Green hills in the background
        ctx.fillStyle = '#2F8B2F';
        
        // Background hills silhouette
        ctx.beginPath();
        ctx.moveTo(0, canvas.height - 80);
        ctx.quadraticCurveTo(100, canvas.height - 120, 200, canvas.height - 90);
        ctx.quadraticCurveTo(350, canvas.height - 70, 500, canvas.height - 100);
        ctx.quadraticCurveTo(700, canvas.height - 130, 900, canvas.height - 85);
        ctx.quadraticCurveTo(1100, canvas.height - 75, canvas.width, canvas.height - 95);
        ctx.lineTo(canvas.width, canvas.height);
        ctx.lineTo(0, canvas.height);
        ctx.closePath();
        ctx.fill();
        
        // Closer hills
        ctx.fillStyle = colors.tree;
        ctx.beginPath();
        ctx.moveTo(0, canvas.height - 40);
        ctx.quadraticCurveTo(150, canvas.height - 65, 300, canvas.height - 45);
        ctx.quadraticCurveTo(500, canvas.height - 30, 700, canvas.height - 55);
        ctx.quadraticCurveTo(900, canvas.height - 70, canvas.width, canvas.height - 50);
        ctx.lineTo(canvas.width, canvas.height);
        ctx.lineTo(0, canvas.height);
        ctx.closePath();
        ctx.fill();
      }

      // Main game loop
      function animate() {
        drawBackground();

        // Update and draw animated clouds
        animatedClouds.forEach(cloud => {
          cloud.update();
          cloud.draw();
        });

        // Update and draw snow
        snowflakes.forEach(snowflake => {
          snowflake.update();
          snowflake.draw();
        });

        // Update and draw platforms
        platforms.forEach(platform => platform.draw());

        // Update and draw coins
        coins.forEach(coin => {
          coin.update();
          coin.draw();
        });

        // Update and draw enemies
        enemies.forEach(enemy => {
          enemy.update();
          enemy.draw();
        });

        // Update and draw Mario
        if (mario) {
          mario.update();
          mario.draw();
        }

        // Update and draw particles
        for (let i = particles.length - 1; i >= 0; i--) {
          const particle = particles[i];
          particle.update();
          particle.draw();
          
          if (particle.life <= 0) {
            particles.splice(i, 1);
          }
        }

        // Add some sparkle effects
        if (Math.random() < 0.1) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height * 0.3;
          particles.push(new Particle(x, y, 0, 1, '#FFFFFF', 60));
        }

        // Occasionally add new snowflakes for dynamic effect
        if (Math.random() < 0.02 && snowflakes.length < 120) {
          snowflakes.push(new Snow());
        }

        requestAnimationFrame(animate);
      }

      // Initialize and start
      initGameWorld();
      animate();
    }

    // Mouse trail animation
    function initMouseTrail() {
      const canvas = document.getElementById('mouseTrail');
      const ctx = canvas.getContext('2d');
      const points = [];
      let mouse = {x: 0, y: 0};

      function setCanvasSize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      setCanvasSize();
      window.addEventListener('resize', setCanvasSize);

      // Track mouse movement
      window.addEventListener('mousemove', (e) => {
        mouse = {x: e.clientX, y: e.clientY};

        points.push({
          x: e.clientX,
          y: e.clientY,
          age: 0
        });

        if (points.length > 30) {
          points.shift();
        }
      });

      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Update points
        for (let i = points.length - 1; i >= 0; i--) {
          points[i].age += 1;
          if (points[i].age > 30) {
            points.splice(i, 1);
          }
        }

        if (points.length > 1) {
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);

          for (let i = 1; i < points.length; i++) {
            const point = points[i];
            const prevPoint = points[i - 1];

            const xc = (point.x + prevPoint.x) / 2;
            const yc = (point.y + prevPoint.y) / 2;
            ctx.quadraticCurveTo(prevPoint.x, prevPoint.y, xc, yc);
          }

          const gradient = ctx.createLinearGradient(
            points[0].x, points[0].y,
            points[points.length - 1].x, points[points.length - 1].y
          );

          gradient.addColorStop(0, 'rgba(6, 182, 212, 0)');
          gradient.addColorStop(0.5, 'rgba(6, 182, 212, 0.5)');
          gradient.addColorStop(1, 'rgba(6, 182, 212, 0.8)');

          ctx.strokeStyle = gradient;
          ctx.lineWidth = 2;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.stroke();

          // Draw dots
          points.forEach((point) => {
            const opacity = 1 - point.age / 30;
            const size = 3 * (1 - point.age / 30);

            ctx.beginPath();
            ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(6, 182, 212, ${opacity})`;
            ctx.fill();

            ctx.shadowBlur = 10;
            ctx.shadowColor = 'rgba(6, 182, 212, 0.5)';
            ctx.fill();
            ctx.shadowBlur = 0;
          });
        }

        requestAnimationFrame(animate);
      }

      animate();
    }

    // Initialize everything when DOM is loaded
    document.addEventListener('DOMContentLoaded', function () {
      // Initialize projects
      displayProjects(projects);

      // Initialize animations
      initPlatformGame();
      initMouseTrail();

      // Animate progress bars when they come into view
      const observeProgressBars = () => {
        const progressBars = document.querySelectorAll('.progress-fill');
        const observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              entry.target.style.width = entry.target.style.width;
            }
          });
        });

        progressBars.forEach(bar => observer.observe(bar));
      };

      observeProgressBars();
    });
  </script>
</body>

</html>
